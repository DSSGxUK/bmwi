{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to BMWi Forecasting Tool About the Project This project is a collaboration between German Federal Ministry for Economic Affairs and Energy (BMWi) and Data Science for Social Good Fellowship, UK . The goal of the project is to build a bottom-up forecasting model for predicting economic development in Germany based on regional data. The bottom-up approach focusses on the predictions at the Kreis (county) level rather than a federal level and provides an alternate approach to forecasting. The project draws on fine-grained data on the demographic, economic and sectoral structure of regions with the aim of improving economic forecasts during times of shocks. The unemployment rate in the different regions of Germany has been used as a proxy for the economic development in that region. Getting Started There are multiple aspects to be explored with this tool. Head over to the getting started page of the documentation! The following video will provide you with an introduction to the tool","title":"Home"},{"location":"#welcome-to-bmwi-forecasting-tool","text":"","title":"Welcome to BMWi Forecasting Tool"},{"location":"#about-the-project","text":"This project is a collaboration between German Federal Ministry for Economic Affairs and Energy (BMWi) and Data Science for Social Good Fellowship, UK . The goal of the project is to build a bottom-up forecasting model for predicting economic development in Germany based on regional data. The bottom-up approach focusses on the predictions at the Kreis (county) level rather than a federal level and provides an alternate approach to forecasting. The project draws on fine-grained data on the demographic, economic and sectoral structure of regions with the aim of improving economic forecasts during times of shocks. The unemployment rate in the different regions of Germany has been used as a proxy for the economic development in that region.","title":"About the Project"},{"location":"#getting-started","text":"There are multiple aspects to be explored with this tool. Head over to the getting started page of the documentation! The following video will provide you with an introduction to the tool","title":"Getting Started"},{"location":"walkforward/","text":"Walk-forward validation This is a validation technique that we have used to evaluate our models. It is different from a simple test-train split because we want to replicate a real world process. We take steps of three months and then retrain the model for the next three months of prediction, this is then applied on the test set for the testing. The steps are mentioned below: - Divide the data into train and test sets. Train dataset includes all the data till the end of 2018. Test dataset includes data from 2019 to current time of 2021 (as of the last time this section was written - May 2021). - Predict for the first three months of 2020 and then add the actual data from the test set to the training set. This step ensures that the models be evaluated the way they would be trained in real-time i.e three months at a time. - After the new training dataset is created, the model is retrained on this data and tested on the next three months. This process keeps happening till the time there is some data remaining. num_iterations = test_data_size/num_of_prediction_steps The process results in a more robust evalutation such that the model can also learn from the short-term and long-term changes. Maybe add a flowchart like illustration for this.","title":"Walk-forward validation"},{"location":"walkforward/#walk-forward-validation","text":"This is a validation technique that we have used to evaluate our models. It is different from a simple test-train split because we want to replicate a real world process. We take steps of three months and then retrain the model for the next three months of prediction, this is then applied on the test set for the testing. The steps are mentioned below: - Divide the data into train and test sets. Train dataset includes all the data till the end of 2018. Test dataset includes data from 2019 to current time of 2021 (as of the last time this section was written - May 2021). - Predict for the first three months of 2020 and then add the actual data from the test set to the training set. This step ensures that the models be evaluated the way they would be trained in real-time i.e three months at a time. - After the new training dataset is created, the model is retrained on this data and tested on the next three months. This process keeps happening till the time there is some data remaining. num_iterations = test_data_size/num_of_prediction_steps The process results in a more robust evalutation such that the model can also learn from the short-term and long-term changes. Maybe add a flowchart like illustration for this.","title":"Walk-forward validation"},{"location":"about/licenses/","text":"","title":"Licences"},{"location":"about/project/","text":"About the Project Project Partners This project is a collaboration between Data Science for Social Good Foundation Fellowship UK and German Federal Ministry of Economic Affairs and Energy (BMWi) . Data Science for Social Good (DSSG) The DSSG Foundation helps NGOs and government bodies achieve more with their data by enhancing their services, interventions and outreach, helping fulfil their mission of improving the world and people\u2019s lives. Its fellowship programme trains students to create industry-standard data science products in collaboration with these agencies to deliver positive social impact. German Federal Ministry of Economics and Energy (BMWi) The main responsibilities of BMWi include supporting SMEs and start-ups, promoting digitization within industrial companies, and designing the path for energy transition. Ultimately, the goal pf BMWi is to ensure Germany\u2019s economic competitiveness and a high level of employment. Project Goal The goal of the project is to robustify BMWi\u2019s economic forecasts by developing a bottom-up model for predicting economic development in Germany based on regional data. The project drew on fine-grained data on the demographic, economic and sectoral structure of county-level data with the aim of improving economic forecasts during times of shocks. More specifically, our team built a open-source tool where BMWi as well as the public would be able to predict unemployment rate in Germany on a county-level for the next three months . Project Data All the data used in this project is available to the public. Regional Statistics Office The unemployment rate data we use for this project is mainly drawn from the labor market statistics section provided by the Regional Statistics Office. Corona Data Platform The structural data we use for this project is mainly drawn from the Corona Data Platform. We use the numerical and categorical data from the platform The Corona Data Platform is part of a project under BMWi in September 2020. The platform contains a combination of epidemiological and socioeconomic variables for analytical evaluations. The socioeconomic variables on the platform are predominantly collected from the Regional Statistics Office.","title":"Project"},{"location":"about/project/#about-the-project","text":"","title":"About the Project"},{"location":"about/project/#project-partners","text":"This project is a collaboration between Data Science for Social Good Foundation Fellowship UK and German Federal Ministry of Economic Affairs and Energy (BMWi) .","title":"Project Partners"},{"location":"about/project/#data-science-for-social-good-dssg","text":"The DSSG Foundation helps NGOs and government bodies achieve more with their data by enhancing their services, interventions and outreach, helping fulfil their mission of improving the world and people\u2019s lives. Its fellowship programme trains students to create industry-standard data science products in collaboration with these agencies to deliver positive social impact.","title":"Data Science for Social Good (DSSG)"},{"location":"about/project/#german-federal-ministry-of-economics-and-energy-bmwi","text":"The main responsibilities of BMWi include supporting SMEs and start-ups, promoting digitization within industrial companies, and designing the path for energy transition. Ultimately, the goal pf BMWi is to ensure Germany\u2019s economic competitiveness and a high level of employment.","title":"German Federal Ministry of Economics and Energy (BMWi)"},{"location":"about/project/#project-goal","text":"The goal of the project is to robustify BMWi\u2019s economic forecasts by developing a bottom-up model for predicting economic development in Germany based on regional data. The project drew on fine-grained data on the demographic, economic and sectoral structure of county-level data with the aim of improving economic forecasts during times of shocks. More specifically, our team built a open-source tool where BMWi as well as the public would be able to predict unemployment rate in Germany on a county-level for the next three months .","title":"Project Goal"},{"location":"about/project/#project-data","text":"All the data used in this project is available to the public.","title":"Project Data"},{"location":"about/project/#regional-statistics-office","text":"The unemployment rate data we use for this project is mainly drawn from the labor market statistics section provided by the Regional Statistics Office.","title":"Regional Statistics Office"},{"location":"about/project/#corona-data-platform","text":"The structural data we use for this project is mainly drawn from the Corona Data Platform. We use the numerical and categorical data from the platform The Corona Data Platform is part of a project under BMWi in September 2020. The platform contains a combination of epidemiological and socioeconomic variables for analytical evaluations. The socioeconomic variables on the platform are predominantly collected from the Regional Statistics Office.","title":"Corona Data Platform"},{"location":"about/team/","text":"Meet the Team This project has been completed in collaboration with Data Science for Social Good Summer Fellowship. The fellows undertaking this project are: Amit Sasson Cinny Lin Prakhar Rathi Vighnesh Natarajan Ganesh The mentors for this project are: Doschmund Kwiatkowski Yurii Tolochko","title":"Team"},{"location":"about/team/#meet-the-team","text":"This project has been completed in collaboration with Data Science for Social Good Summer Fellowship. The fellows undertaking this project are: Amit Sasson Cinny Lin Prakhar Rathi Vighnesh Natarajan Ganesh The mentors for this project are: Doschmund Kwiatkowski Yurii Tolochko","title":"Meet the Team"},{"location":"about/tool/","text":"About the tool This is a forecasting tool built using Streamlit to forecast the unemployment rate for the next three months at the Kreis level in Germany. The purpose of the tool is to provide a complete pipeline from data analysis to model predictions in a simple easy-to-acess UI. Tool Architecture The following diagram shows the tool architecture which includes the data processing, predictions and deployment. Streamlit Settings Once you have started the tool, there are ways to customize your application. Start by selecting the dropdown on the top right of the page. Go to Settings . Select Wide Mode if you want the application to appear in a wider format. You can also change the application colors by selecting the theme dropdown option. You can find the references for the application below.","title":"Tool"},{"location":"about/tool/#about-the-tool","text":"This is a forecasting tool built using Streamlit to forecast the unemployment rate for the next three months at the Kreis level in Germany. The purpose of the tool is to provide a complete pipeline from data analysis to model predictions in a simple easy-to-acess UI.","title":"About the tool"},{"location":"about/tool/#tool-architecture","text":"The following diagram shows the tool architecture which includes the data processing, predictions and deployment.","title":"Tool Architecture"},{"location":"about/tool/#streamlit-settings","text":"Once you have started the tool, there are ways to customize your application. Start by selecting the dropdown on the top right of the page. Go to Settings . Select Wide Mode if you want the application to appear in a wider format. You can also change the application colors by selecting the theme dropdown option. You can find the references for the application below.","title":"Streamlit Settings"},{"location":"advanced/cleanerclass/","text":"CleanerClass Explained This page walks through the assumptions and the implementation code for the excel sheet cleaner. Purpose of the CleanerClass The excel sheet cleaner is used on the Data Prep page to get the formatted data for our forecast model from excel workbooks. The goal of the CleanerClass is to retrieve a python friendly format of the data, containing only the essential index columns, variable columns, and the numerical values of the data. Worksheets that contain only metadata or descriptions would be discarded, and the watermark-like header rows would also be cropped out in the process. Assumed Formatting for the CleanerClass As explained briefly in the Data Prep page, below is the expected structure of the excel workbook. The assumptions for the input excel workbook are as follows: every kreis is a row although every row need not be a kreis for example, there are also rows that represents the whole bundesland all 401 kreis's AGS5 values must exist, and exist in the same column The ags5 values for cities like Berlin and Hamburg must exist (not just their ags2 values) the left most column of the table has the ags5 code value the left most column of the table need not be left most column of sheet \"sheet\" describes a single Excel sheet, and \"table\" describes the acutual tabular data (along with the indexes and columns) thus, once the CleanerClass finds the ags5 column, that column becomes the left most column of the output table, and every column left to the ags5 column would be cropped out in other words, no data should be recorded to the left on the ags5 column also, any essential columns should also be recorded to the right of the ags5 column every column is a time-stamp the input excel workbook is expected to be in wide format (i.e., kreise are rows; timestamps are columns) however, after cleaning, the CleanerClass can provide both wide and long formats there must be atleast 5 timestamps every cell is a numeric value categorical values are not permitted in the worksheet any column with non-numeric data (like: 'Zero', 'Does not exist', null), will be dropped (only if the non-numeric data exists in a row containing an AGS5 value, below the row containing the timestamps) As long as aforementioned assumptions are met in the input excel workbook, this CleanerClass should export suitable formats for the model. Code Walkthrough This page would go through the implementation of the cleanerclass in detail. Class Initiation First, we import the necessary library, pandas , to read in excel workbook in Python. Second, we set a variable called AGS5_LIST , which is a list that stores all the ags5 code in numerical value. # import requirements import pandas as pd #global variable: list of ags5 codes, numeric data type AGS5_LIST = [ 1001, 1002, 1003, 1004, 1051, 1053, 1054, 1055, ...] Then, we start writing the CleanerClass. First, we initiate the attributes for the class. self.sheet : stores the useful worksheets read from the input workbook into a dictionary self.thrownAwayColumns : stores the name and value of the columns that were discarded in each worksheet into a dictionary self.thrownAwayRows : stores the rows that were discarded in each worksheet into a dictionary self.sheet_to_df_map : stores all the worksheets of the workbook into a dictionary, where the key is the name of the worksheet, and the value is the worksheet dataframe class CleanerClass: def __init__(self, file_location, verbose=True): self.verbose = verbose self.sheets = {} # by default we store it in the wide format self.thrownAwayColumns = {} self.thrownAwayRows = {} if verbose: print(\"Reading the file...\") # use sheet_name = None to read all sheets as an ordered dict self.sheet_to_df_map = pd.read_excel(file_location, engine='openpyxl', sheet_name=None) if verbose: print(\"file read complete!\") for sheet_name, sheet_df in self.sheet_to_df_map.items() loops through each worksheet in the workbook using the self.sheet_to_df_map dictionary that we initializes in the last step. sheet = sheet_df.copy() makes a deep copy of each worksheet dataframe, so that any processing made from this point on would not affect the data from the actual worksheet itself. for sheet_name, sheet_df in self.sheet_to_df_map.items(): ## loop through all the sheets sheet = sheet_df.copy() if self.verbose: print(\"\\nprocessing the sheet \", sheet_name, end='') if self.verbose: print('.', end='') 0. Check metadata sheet If the sheet does not have at least 401 rows, it is not a useful sheet. Because we assume the worksheet to follow the format that each kreis is a separate row, and that there are 401 kreise in Germany. This step discards the sheets that contain descriptions instead of numerical-valued data. if sheet.shape[0] < 401: continue # to the next sheet 1. Find the starting column of the table To check if the column is an ags5 column, and not just a column that happen to a variable column that contains the ags5 values. To do this, we randomly selected three ags5 codes from three kreise and checked if all three codes were in the column. If so, it is an ags5 column, and the sheet is one that we can possibly work with. #KREIS_NAMES_TO_CHECK = ['hamburg', 'berlin', 'kiel'] KREIS_CODES_TO_CHECK = ['02000', '11000', '01002'] KREIS_COL_NO = None KREIS_COL_NAME = None for kreis_code in KREIS_CODES_TO_CHECK: for i, col in enumerate(sheet.columns): # find if kreis name is in a substring substring_loc = sheet[col].str.contains(kreis_code, case=False) # returns a number >0 (position where kreis_code starts) found = sum(substring_loc > 0) # if found, just break away, no need to look anymore if found: if KREIS_COL_NO is None: KREIS_COL_NO = i KREIS_COL_NAME = col else: assert KREIS_COL_NO == i break if KREIS_COL_NAME is None: # no column was found with the kreis names # therefore, not a useful sheet continue # to the next sheet if self.verbose: print('.', end='') 2. Find the starting row of the table In step 1 , we found the starting column, ags5 . This step, we find the starting index. To find the starting row, we find the row with dates. Here, we set an arbitrary cutoff at 5. When a row contains at least 5 values that are dates, we consider that row to be the date row with date columns, and consider that row to be the starting row of the table. col_names = sheet.columns DATE_COUNT_CUTOFF = 5 # the number of dates a column must have to qualify as the row which has the table's col names ROW_WITH_DATES = None sheet.reset_index(drop=True, inplace=True) # reset index so that we have the index as a range starting from 0 for index, row in sheet.iterrows(): is_date_arr = [self.is_date(str(row[col_name])) for col_name in col_names] if sum(is_date_arr) >= DATE_COUNT_CUTOFF: # we found the row! ROW_WITH_DATES = index break if ROW_WITH_DATES is None: # no row had dates # therefore, not a table with time series data # therefore not a useful sheet (sheet with needed data) continue # to the next sheet if self.verbose: print('.', end='') 3. Crop out the table 3.1 Crop the columns As explained earlier, step 1 finds the ags5 column, which we consider to be the starting column of the table. This step crops out all the other columns left to the ags5 column. In other words, any important index columns in the worksheet should be recorded on the right to the ags5 column. Note : The CleanerClass currenly does not handle the right boundary of the table because it is automatically handled in the pd.read_excel function. However, if there is any metadata on the right side, it should be cleaned manually before inputting to the cleanerclass. columns_to_drop = [] for col_name in sheet.columns: if col_name == KREIS_COL_NAME: # end the loop break columns_to_drop.append(col_name) sheet.drop(columns_to_drop, axis=1, inplace=True) sheet.set_index(KREIS_COL_NAME, inplace=True) 3.2 Crop the rows As explained earlier, step 2 finds the row that contains the date columns, which we consider to be the starting row of the table. This step crops all the other rows above the date-columns row. sheet.columns = list(sheet.iloc[ROW_WITH_DATES]) sheet = sheet.iloc[ROW_WITH_DATES+1:] sheet.index.name = None if self.verbose: print('.', end='') 4. Throw away rows that are not kreis This step goes through all the rest of the rows below the date-columns row, and discard the ones that are not records on a kreis-level. For implementation, it checks whether the area code in the ags5 column is in the AGS5_LIST we initiated. A special situation to consider are kreise like Hamburg and Berlin, where they are a county (\"kreis\") and a state (\"bundesland\") at the same time. We want to make sure however it is recorded in the worksheet, it would be included to our final table and not accidentally discarded by our cleaner. AGS5_LIST_TEMP = self.AGS5_LIST.copy() #new_index = [] rows_to_drop = [] for index, row in sheet.iterrows(): row_is_needed = False for ags5_loc, ags5 in enumerate(AGS5_LIST_TEMP): if \"{:05d}\".format(ags5) == str(index): AGS5_LIST_TEMP.pop(ags5_loc) # remove that ags5 from AGS5_LIST_TEMP #new_index.append(ags5) # add that index row_is_needed = True # We need this row break # no need to search for other ags5 in AGS5_LIST_TEMP if row_is_needed is False: rows_to_drop.append(index) if len(AGS5_LIST_TEMP) == 2: # berlin and hamburg are not divided down into it's kreis BERLIN_HAMBURG = [2000, 11000] BERLIN_HAMBURG_STR = [\"{:05d}\".format(ags5) for ags5 in BERLIN_HAMBURG] BERLIN_HAMBURG_ags2 = [2, 11] BERLIN_HAMBURG_ags2_STR = [\"{:02d}\".format(ags2) for ags2 in BERLIN_HAMBURG_ags2] ags5s_to_pop = [] for ags5_loc, ags5 in enumerate(AGS5_LIST_TEMP): if ags5 in BERLIN_HAMBURG or BERLIN_HAMBURG_STR: # this bundesland is not then subdivided bacause these 2 bunds. have only one kreis under them # so use the bundesland info as the kreis info ags5s_to_pop.append(ags5_loc) #new_index.append(ags5) for i in range(len(BERLIN_HAMBURG)): if ags5 == BERLIN_HAMBURG[i] or ags5 == BERLIN_HAMBURG_STR[i]: try: rows_to_drop.remove(BERLIN_HAMBURG_ags2[i]) # replace the ags2 index with corresponding ags5 sheet.index = [BERLIN_HAMBURG_STR[i] if ind == BERLIN_HAMBURG_ags2_STR[i] else ind for ind in sheet.index] except: rows_to_drop.remove(BERLIN_HAMBURG_ags2_STR[i]) sheet.index = [BERLIN_HAMBURG_STR[i] if ind == BERLIN_HAMBURG_ags2_STR[i] else ind for ind in sheet.index] break ags5s_to_pop.sort(reverse=True) for ags5_loc in ags5s_to_pop: AGS5_LIST_TEMP.pop(ags5_loc) if len(AGS5_LIST_TEMP) != 0: # some ags5 does not exist! continue # to next sheet sheet.drop(rows_to_drop, axis=0, inplace=True) sheet.index = [int(ind) for ind in sheet.index] self.thrownAwayRows[sheet_name] = rows_to_drop if self.verbose: print('.', end='') 5. Check columns data type This step goes through each columns, and discards the columns where the value is not numerical. The discarded columns are stored in the self.thrownAwayColumns dictionary we initiated at the start. cols_with_non_numeric_vals = [] for col in sheet.columns: try: # find if the col has int or float as dtype: rem = sheet[col] % 1 if sum(rem) == 0: col_type = 'int64' else: col_type = 'float64' sheet[col] = sheet[col].astype(col_type) except: # col cannot be converted to numeric type cols_with_non_numeric_vals.append(col) sheet.drop(cols_with_non_numeric_vals, axis=1, inplace=True) self.thrownAwayColumns[sheet_name] = cols_with_non_numeric_vals if self.verbose: print('.', end='') 6. Drop columns with NA 6.1 Drop all column names as NA Drop the column names that are not a valid date. sheet = sheet[sheet.columns.dropna()] 6.2 Drop columns with NA values Drop the columns with NA values and store the variable names to the self.thrownAwayColumns dictionary we initiated from the start. cols_with_na = sheet.columns[sheet.isnull().any()] sheet.drop(cols_with_na, axis=1, inplace=True) self.thrownAwayColumns[sheet_name].extend(cols_with_na) if self.verbose: print('.', end='') 7. Set the ags5 index to string of length 5 Unify the format of the ags5 codes to be length of 5, data type string. For example, the original area code 1001 , data type int would be converted to 01001 , data type str . sheet.index = [\"{:05d}\".format(ags5) for ags5 in sheet.index] 8. Sort the sheet by ags5 value sheet = sheet.sort_index() 9. Throw away empty sheets If the shape of the sheet is empty, discard this sheet and move on to the next sheet. if 0 in sheet.shape: continue # to next sheet Class Attributes Define functions of the class. In implementation, once a class is called, we can use these pre-defined functions within the class to access the dictionaries and other values we stored in the class initiation steps. is_date This function takes a string and returns whether the string can be interpreted as a date. def is_date(self, string, fuzzy=False): from dateutil.parser import parse if isinstance(string, str): try: parse(string, fuzzy=fuzzy) return True except ValueError: # not a string that can be parsed return False else: # not a string at all return False getAllUsefulSheets_wide The assumed input data format is wide format. Thus, all the useful sheets are stored in wide format by default. def getAllUsefulSheets_wide(self): return self.sheets getAllUsefulSheets_long As explained above, wide format is the assumed input format and default output format. To get long formats of the sheet, we need to do some reshaping of the data. def getAllUsefulSheets_long(self): try: return self.sheets_long except AttributeError: self.sheets_long = {} for df_name, df_og in self.sheets.items(): df = df_og.copy() df = pd.DataFrame([ [ags5, time_stamp, row[time_stamp]] for ags5, row in df.iterrows() for time_stamp in df.columns ]) df.columns = ['ags5', 'time_stamp', 'value'] self.sheets_long[df_name] = df return self.sheets_long getThrownAwayRows The discarded rows are stored in the self.thrownAwayRows dictionary we initiated at the start. def getThrownAwayRows(self): return self.thrownAwayRows getThrownAwayColumns The discarded columns are stored in the self.thrownAwayColumns dictionary we initiated at the start. def getThrownAwayColumns(self): return self.thrownAwayColumns","title":"Cleaner Class"},{"location":"advanced/cleanerclass/#cleanerclass-explained","text":"This page walks through the assumptions and the implementation code for the excel sheet cleaner.","title":"CleanerClass Explained"},{"location":"advanced/cleanerclass/#purpose-of-the-cleanerclass","text":"The excel sheet cleaner is used on the Data Prep page to get the formatted data for our forecast model from excel workbooks. The goal of the CleanerClass is to retrieve a python friendly format of the data, containing only the essential index columns, variable columns, and the numerical values of the data. Worksheets that contain only metadata or descriptions would be discarded, and the watermark-like header rows would also be cropped out in the process.","title":"Purpose of the CleanerClass"},{"location":"advanced/cleanerclass/#assumed-formatting-for-the-cleanerclass","text":"As explained briefly in the Data Prep page, below is the expected structure of the excel workbook. The assumptions for the input excel workbook are as follows: every kreis is a row although every row need not be a kreis for example, there are also rows that represents the whole bundesland all 401 kreis's AGS5 values must exist, and exist in the same column The ags5 values for cities like Berlin and Hamburg must exist (not just their ags2 values) the left most column of the table has the ags5 code value the left most column of the table need not be left most column of sheet \"sheet\" describes a single Excel sheet, and \"table\" describes the acutual tabular data (along with the indexes and columns) thus, once the CleanerClass finds the ags5 column, that column becomes the left most column of the output table, and every column left to the ags5 column would be cropped out in other words, no data should be recorded to the left on the ags5 column also, any essential columns should also be recorded to the right of the ags5 column every column is a time-stamp the input excel workbook is expected to be in wide format (i.e., kreise are rows; timestamps are columns) however, after cleaning, the CleanerClass can provide both wide and long formats there must be atleast 5 timestamps every cell is a numeric value categorical values are not permitted in the worksheet any column with non-numeric data (like: 'Zero', 'Does not exist', null), will be dropped (only if the non-numeric data exists in a row containing an AGS5 value, below the row containing the timestamps) As long as aforementioned assumptions are met in the input excel workbook, this CleanerClass should export suitable formats for the model.","title":"Assumed Formatting for the CleanerClass"},{"location":"advanced/cleanerclass/#code-walkthrough","text":"This page would go through the implementation of the cleanerclass in detail.","title":"Code Walkthrough"},{"location":"advanced/cleanerclass/#class-initiation","text":"First, we import the necessary library, pandas , to read in excel workbook in Python. Second, we set a variable called AGS5_LIST , which is a list that stores all the ags5 code in numerical value. # import requirements import pandas as pd #global variable: list of ags5 codes, numeric data type AGS5_LIST = [ 1001, 1002, 1003, 1004, 1051, 1053, 1054, 1055, ...] Then, we start writing the CleanerClass. First, we initiate the attributes for the class. self.sheet : stores the useful worksheets read from the input workbook into a dictionary self.thrownAwayColumns : stores the name and value of the columns that were discarded in each worksheet into a dictionary self.thrownAwayRows : stores the rows that were discarded in each worksheet into a dictionary self.sheet_to_df_map : stores all the worksheets of the workbook into a dictionary, where the key is the name of the worksheet, and the value is the worksheet dataframe class CleanerClass: def __init__(self, file_location, verbose=True): self.verbose = verbose self.sheets = {} # by default we store it in the wide format self.thrownAwayColumns = {} self.thrownAwayRows = {} if verbose: print(\"Reading the file...\") # use sheet_name = None to read all sheets as an ordered dict self.sheet_to_df_map = pd.read_excel(file_location, engine='openpyxl', sheet_name=None) if verbose: print(\"file read complete!\") for sheet_name, sheet_df in self.sheet_to_df_map.items() loops through each worksheet in the workbook using the self.sheet_to_df_map dictionary that we initializes in the last step. sheet = sheet_df.copy() makes a deep copy of each worksheet dataframe, so that any processing made from this point on would not affect the data from the actual worksheet itself. for sheet_name, sheet_df in self.sheet_to_df_map.items(): ## loop through all the sheets sheet = sheet_df.copy() if self.verbose: print(\"\\nprocessing the sheet \", sheet_name, end='') if self.verbose: print('.', end='')","title":"Class Initiation"},{"location":"advanced/cleanerclass/#0-check-metadata-sheet","text":"If the sheet does not have at least 401 rows, it is not a useful sheet. Because we assume the worksheet to follow the format that each kreis is a separate row, and that there are 401 kreise in Germany. This step discards the sheets that contain descriptions instead of numerical-valued data. if sheet.shape[0] < 401: continue # to the next sheet","title":"0. Check metadata sheet"},{"location":"advanced/cleanerclass/#1-find-the-starting-column-of-the-table","text":"To check if the column is an ags5 column, and not just a column that happen to a variable column that contains the ags5 values. To do this, we randomly selected three ags5 codes from three kreise and checked if all three codes were in the column. If so, it is an ags5 column, and the sheet is one that we can possibly work with. #KREIS_NAMES_TO_CHECK = ['hamburg', 'berlin', 'kiel'] KREIS_CODES_TO_CHECK = ['02000', '11000', '01002'] KREIS_COL_NO = None KREIS_COL_NAME = None for kreis_code in KREIS_CODES_TO_CHECK: for i, col in enumerate(sheet.columns): # find if kreis name is in a substring substring_loc = sheet[col].str.contains(kreis_code, case=False) # returns a number >0 (position where kreis_code starts) found = sum(substring_loc > 0) # if found, just break away, no need to look anymore if found: if KREIS_COL_NO is None: KREIS_COL_NO = i KREIS_COL_NAME = col else: assert KREIS_COL_NO == i break if KREIS_COL_NAME is None: # no column was found with the kreis names # therefore, not a useful sheet continue # to the next sheet if self.verbose: print('.', end='')","title":"1. Find the starting column of the table"},{"location":"advanced/cleanerclass/#2-find-the-starting-row-of-the-table","text":"In step 1 , we found the starting column, ags5 . This step, we find the starting index. To find the starting row, we find the row with dates. Here, we set an arbitrary cutoff at 5. When a row contains at least 5 values that are dates, we consider that row to be the date row with date columns, and consider that row to be the starting row of the table. col_names = sheet.columns DATE_COUNT_CUTOFF = 5 # the number of dates a column must have to qualify as the row which has the table's col names ROW_WITH_DATES = None sheet.reset_index(drop=True, inplace=True) # reset index so that we have the index as a range starting from 0 for index, row in sheet.iterrows(): is_date_arr = [self.is_date(str(row[col_name])) for col_name in col_names] if sum(is_date_arr) >= DATE_COUNT_CUTOFF: # we found the row! ROW_WITH_DATES = index break if ROW_WITH_DATES is None: # no row had dates # therefore, not a table with time series data # therefore not a useful sheet (sheet with needed data) continue # to the next sheet if self.verbose: print('.', end='')","title":"2. Find the starting row of the table"},{"location":"advanced/cleanerclass/#3-crop-out-the-table","text":"","title":"3. Crop out the table"},{"location":"advanced/cleanerclass/#31-crop-the-columns","text":"As explained earlier, step 1 finds the ags5 column, which we consider to be the starting column of the table. This step crops out all the other columns left to the ags5 column. In other words, any important index columns in the worksheet should be recorded on the right to the ags5 column. Note : The CleanerClass currenly does not handle the right boundary of the table because it is automatically handled in the pd.read_excel function. However, if there is any metadata on the right side, it should be cleaned manually before inputting to the cleanerclass. columns_to_drop = [] for col_name in sheet.columns: if col_name == KREIS_COL_NAME: # end the loop break columns_to_drop.append(col_name) sheet.drop(columns_to_drop, axis=1, inplace=True) sheet.set_index(KREIS_COL_NAME, inplace=True)","title":"3.1 Crop the columns"},{"location":"advanced/cleanerclass/#32-crop-the-rows","text":"As explained earlier, step 2 finds the row that contains the date columns, which we consider to be the starting row of the table. This step crops all the other rows above the date-columns row. sheet.columns = list(sheet.iloc[ROW_WITH_DATES]) sheet = sheet.iloc[ROW_WITH_DATES+1:] sheet.index.name = None if self.verbose: print('.', end='')","title":"3.2 Crop the rows"},{"location":"advanced/cleanerclass/#4-throw-away-rows-that-are-not-kreis","text":"This step goes through all the rest of the rows below the date-columns row, and discard the ones that are not records on a kreis-level. For implementation, it checks whether the area code in the ags5 column is in the AGS5_LIST we initiated. A special situation to consider are kreise like Hamburg and Berlin, where they are a county (\"kreis\") and a state (\"bundesland\") at the same time. We want to make sure however it is recorded in the worksheet, it would be included to our final table and not accidentally discarded by our cleaner. AGS5_LIST_TEMP = self.AGS5_LIST.copy() #new_index = [] rows_to_drop = [] for index, row in sheet.iterrows(): row_is_needed = False for ags5_loc, ags5 in enumerate(AGS5_LIST_TEMP): if \"{:05d}\".format(ags5) == str(index): AGS5_LIST_TEMP.pop(ags5_loc) # remove that ags5 from AGS5_LIST_TEMP #new_index.append(ags5) # add that index row_is_needed = True # We need this row break # no need to search for other ags5 in AGS5_LIST_TEMP if row_is_needed is False: rows_to_drop.append(index) if len(AGS5_LIST_TEMP) == 2: # berlin and hamburg are not divided down into it's kreis BERLIN_HAMBURG = [2000, 11000] BERLIN_HAMBURG_STR = [\"{:05d}\".format(ags5) for ags5 in BERLIN_HAMBURG] BERLIN_HAMBURG_ags2 = [2, 11] BERLIN_HAMBURG_ags2_STR = [\"{:02d}\".format(ags2) for ags2 in BERLIN_HAMBURG_ags2] ags5s_to_pop = [] for ags5_loc, ags5 in enumerate(AGS5_LIST_TEMP): if ags5 in BERLIN_HAMBURG or BERLIN_HAMBURG_STR: # this bundesland is not then subdivided bacause these 2 bunds. have only one kreis under them # so use the bundesland info as the kreis info ags5s_to_pop.append(ags5_loc) #new_index.append(ags5) for i in range(len(BERLIN_HAMBURG)): if ags5 == BERLIN_HAMBURG[i] or ags5 == BERLIN_HAMBURG_STR[i]: try: rows_to_drop.remove(BERLIN_HAMBURG_ags2[i]) # replace the ags2 index with corresponding ags5 sheet.index = [BERLIN_HAMBURG_STR[i] if ind == BERLIN_HAMBURG_ags2_STR[i] else ind for ind in sheet.index] except: rows_to_drop.remove(BERLIN_HAMBURG_ags2_STR[i]) sheet.index = [BERLIN_HAMBURG_STR[i] if ind == BERLIN_HAMBURG_ags2_STR[i] else ind for ind in sheet.index] break ags5s_to_pop.sort(reverse=True) for ags5_loc in ags5s_to_pop: AGS5_LIST_TEMP.pop(ags5_loc) if len(AGS5_LIST_TEMP) != 0: # some ags5 does not exist! continue # to next sheet sheet.drop(rows_to_drop, axis=0, inplace=True) sheet.index = [int(ind) for ind in sheet.index] self.thrownAwayRows[sheet_name] = rows_to_drop if self.verbose: print('.', end='')","title":"4. Throw away rows that are not kreis"},{"location":"advanced/cleanerclass/#5-check-columns-data-type","text":"This step goes through each columns, and discards the columns where the value is not numerical. The discarded columns are stored in the self.thrownAwayColumns dictionary we initiated at the start. cols_with_non_numeric_vals = [] for col in sheet.columns: try: # find if the col has int or float as dtype: rem = sheet[col] % 1 if sum(rem) == 0: col_type = 'int64' else: col_type = 'float64' sheet[col] = sheet[col].astype(col_type) except: # col cannot be converted to numeric type cols_with_non_numeric_vals.append(col) sheet.drop(cols_with_non_numeric_vals, axis=1, inplace=True) self.thrownAwayColumns[sheet_name] = cols_with_non_numeric_vals if self.verbose: print('.', end='')","title":"5. Check columns data type"},{"location":"advanced/cleanerclass/#6-drop-columns-with-na","text":"","title":"6. Drop columns with NA"},{"location":"advanced/cleanerclass/#61-drop-all-column-names-as-na","text":"Drop the column names that are not a valid date. sheet = sheet[sheet.columns.dropna()]","title":"6.1 Drop all column names as NA"},{"location":"advanced/cleanerclass/#62-drop-columns-with-na-values","text":"Drop the columns with NA values and store the variable names to the self.thrownAwayColumns dictionary we initiated from the start. cols_with_na = sheet.columns[sheet.isnull().any()] sheet.drop(cols_with_na, axis=1, inplace=True) self.thrownAwayColumns[sheet_name].extend(cols_with_na) if self.verbose: print('.', end='')","title":"6.2 Drop columns with NA values"},{"location":"advanced/cleanerclass/#7-set-the-ags5-index-to-string-of-length-5","text":"Unify the format of the ags5 codes to be length of 5, data type string. For example, the original area code 1001 , data type int would be converted to 01001 , data type str . sheet.index = [\"{:05d}\".format(ags5) for ags5 in sheet.index]","title":"7. Set the ags5 index to string of length 5"},{"location":"advanced/cleanerclass/#8-sort-the-sheet-by-ags5-value","text":"sheet = sheet.sort_index()","title":"8. Sort the sheet by ags5 value"},{"location":"advanced/cleanerclass/#9-throw-away-empty-sheets","text":"If the shape of the sheet is empty, discard this sheet and move on to the next sheet. if 0 in sheet.shape: continue # to next sheet","title":"9. Throw away empty sheets"},{"location":"advanced/cleanerclass/#class-attributes","text":"Define functions of the class. In implementation, once a class is called, we can use these pre-defined functions within the class to access the dictionaries and other values we stored in the class initiation steps.","title":"Class Attributes"},{"location":"advanced/cleanerclass/#is_date","text":"This function takes a string and returns whether the string can be interpreted as a date. def is_date(self, string, fuzzy=False): from dateutil.parser import parse if isinstance(string, str): try: parse(string, fuzzy=fuzzy) return True except ValueError: # not a string that can be parsed return False else: # not a string at all return False","title":"is_date"},{"location":"advanced/cleanerclass/#getallusefulsheets_wide","text":"The assumed input data format is wide format. Thus, all the useful sheets are stored in wide format by default. def getAllUsefulSheets_wide(self): return self.sheets","title":"getAllUsefulSheets_wide"},{"location":"advanced/cleanerclass/#getallusefulsheets_long","text":"As explained above, wide format is the assumed input format and default output format. To get long formats of the sheet, we need to do some reshaping of the data. def getAllUsefulSheets_long(self): try: return self.sheets_long except AttributeError: self.sheets_long = {} for df_name, df_og in self.sheets.items(): df = df_og.copy() df = pd.DataFrame([ [ags5, time_stamp, row[time_stamp]] for ags5, row in df.iterrows() for time_stamp in df.columns ]) df.columns = ['ags5', 'time_stamp', 'value'] self.sheets_long[df_name] = df return self.sheets_long","title":"getAllUsefulSheets_long"},{"location":"advanced/cleanerclass/#getthrownawayrows","text":"The discarded rows are stored in the self.thrownAwayRows dictionary we initiated at the start. def getThrownAwayRows(self): return self.thrownAwayRows","title":"getThrownAwayRows"},{"location":"advanced/cleanerclass/#getthrownawaycolumns","text":"The discarded columns are stored in the self.thrownAwayColumns dictionary we initiated at the start. def getThrownAwayColumns(self): return self.thrownAwayColumns","title":"getThrownAwayColumns"},{"location":"advanced/installation/","text":"Technical Documentation This section is for people who might want to edit the code base of the application. The repository with all the code can be found here . The application is built using the following tools and frameworks: Python Streamlit Pandas Statsmodels To make edits to the tool, one must know how to work with the aforementioned frameworks. More details about each of them can be found on the links provided above. About Streamlit This application is built using Streamlit , a Python framework to build interactive web applications. It has a rich API for various interactive features which can be learnt more about here . It's a relatively new framework and its recommended to explore building basic apps with it before diving deep into the repository. To set up the repository on your local machine follow the installation steps below: Installation Steps To set up the application on your local machine, follow these steps. Clone the repository on your local machine git clone <link> Create a virtual environment For MacOS/Linux - ``python3 -m venv env For Windows - py -m venv env The second argument is the location to create the virtual environment. Generally, you can just create this in your project and call it env . Read more about virtual env here . Note: You should exclude your virtual environment directory from your version control system using .gitignore or similar. Activate the virtual environment For MacOS/Linux - source env/bin/activate For Windows - .\\env\\Scripts\\activate Install requirements pip install -r requirements.txt Run the streamlit app streamlit run app.py","title":"Installation and Setup"},{"location":"advanced/installation/#technical-documentation","text":"This section is for people who might want to edit the code base of the application. The repository with all the code can be found here . The application is built using the following tools and frameworks: Python Streamlit Pandas Statsmodels To make edits to the tool, one must know how to work with the aforementioned frameworks. More details about each of them can be found on the links provided above.","title":"Technical Documentation"},{"location":"advanced/installation/#about-streamlit","text":"This application is built using Streamlit , a Python framework to build interactive web applications. It has a rich API for various interactive features which can be learnt more about here . It's a relatively new framework and its recommended to explore building basic apps with it before diving deep into the repository. To set up the repository on your local machine follow the installation steps below:","title":"About Streamlit"},{"location":"advanced/installation/#installation-steps","text":"To set up the application on your local machine, follow these steps. Clone the repository on your local machine git clone <link> Create a virtual environment For MacOS/Linux - ``python3 -m venv env For Windows - py -m venv env The second argument is the location to create the virtual environment. Generally, you can just create this in your project and call it env . Read more about virtual env here . Note: You should exclude your virtual environment directory from your version control system using .gitignore or similar. Activate the virtual environment For MacOS/Linux - source env/bin/activate For Windows - .\\env\\Scripts\\activate Install requirements pip install -r requirements.txt Run the streamlit app streamlit run app.py","title":"Installation Steps"},{"location":"advanced/tech_flow/","text":"Technical Workflow mermaid.initialize({startOnLoad:true}); mermaidAPI.initialize({ securityLevel: 'loose' }); Pro Tip : Clicking on the purple nodes leads to the source code. graph TD subgraph Dataset Prep page A[time-series excel workbook with CleanerClass] end subgraph Model page B[Unemployment Rate Prediction on Kreis-level] C[Visualization: line plot, map of Germany] D[Output file: single excel worksheet] B --> C --> D end subgraph Error Analysis page E[Error Analysis] end subgraph Home page F[rankings & groups] end A --> B D --> E D --> F click A \"https://github.com/DSSGxUK/bmwi/blob/main/pages/data_prep.py\" click B \"https://github.com/DSSGxUK/bmwi/blob/main/pages/model_page.py\" click C \"https://github.com/DSSGxUK/bmwi/blob/main/pages/prediction_viz.py\" click D \"https://github.com/DSSGxUK/bmwi/blob/main/pages/model_page.py\" click E \"https://github.com/DSSGxUK/bmwi/blob/main/pages/error_analysis.py\" click F \"https://github.com/DSSGxUK/bmwi/blob/main/pages/ranking.py\"","title":"Technical Workflow"},{"location":"advanced/tech_flow/#technical-workflow","text":"mermaid.initialize({startOnLoad:true}); mermaidAPI.initialize({ securityLevel: 'loose' }); Pro Tip : Clicking on the purple nodes leads to the source code. graph TD subgraph Dataset Prep page A[time-series excel workbook with CleanerClass] end subgraph Model page B[Unemployment Rate Prediction on Kreis-level] C[Visualization: line plot, map of Germany] D[Output file: single excel worksheet] B --> C --> D end subgraph Error Analysis page E[Error Analysis] end subgraph Home page F[rankings & groups] end A --> B D --> E D --> F click A \"https://github.com/DSSGxUK/bmwi/blob/main/pages/data_prep.py\" click B \"https://github.com/DSSGxUK/bmwi/blob/main/pages/model_page.py\" click C \"https://github.com/DSSGxUK/bmwi/blob/main/pages/prediction_viz.py\" click D \"https://github.com/DSSGxUK/bmwi/blob/main/pages/model_page.py\" click E \"https://github.com/DSSGxUK/bmwi/blob/main/pages/error_analysis.py\" click F \"https://github.com/DSSGxUK/bmwi/blob/main/pages/ranking.py\"","title":"Technical Workflow"},{"location":"journey/GDP/","text":"GDP and Unemployment rate We recived yearly data on GDP on a kreis level, and investigated the relationship it has to unemployment rate in a kreis level. Okun's law Okun's law describes the relationship between changes in unemployment and changes in GDP. It assumes that the change in the unemployment rate, is approximately equal to 0. It also assumes that the relative employment rate change, is approximately constant. Unfortunately, these assumptions don't hold in our data. GDP and Unemployment rate linear correlation We investigated the relationship between the yearly GDP and yearly unemployment rate of 2008-2018. First, we plotted them for all kreise together, each kreis in a different color. We realised that there is no linear relationship. Then, we did the same with the change in GDP versus the change in unemployment rate. This means, for each year, the current value minus the previous year's value. This did not yield a linear relationship either. Then, we did the same with the relative change in GDP versus the relative change in unemployment rate. This means, for each year, the current value minus the previous year's value, divided by the previous year's value. This did not yield a linear relationship either. Finally, we ploted the GDP per capita, but this did not yield a linear relationship either. To sum up, we couldn't find any linear relationship between yearly GDP and unemployment rate,","title":"GDP and Unemployment rate"},{"location":"journey/GDP/#gdp-and-unemployment-rate","text":"We recived yearly data on GDP on a kreis level, and investigated the relationship it has to unemployment rate in a kreis level.","title":"GDP and Unemployment rate"},{"location":"journey/GDP/#okuns-law","text":"Okun's law describes the relationship between changes in unemployment and changes in GDP. It assumes that the change in the unemployment rate, is approximately equal to 0. It also assumes that the relative employment rate change, is approximately constant. Unfortunately, these assumptions don't hold in our data.","title":"Okun's law"},{"location":"journey/GDP/#gdp-and-unemployment-rate-linear-correlation","text":"We investigated the relationship between the yearly GDP and yearly unemployment rate of 2008-2018. First, we plotted them for all kreise together, each kreis in a different color. We realised that there is no linear relationship. Then, we did the same with the change in GDP versus the change in unemployment rate. This means, for each year, the current value minus the previous year's value. This did not yield a linear relationship either. Then, we did the same with the relative change in GDP versus the relative change in unemployment rate. This means, for each year, the current value minus the previous year's value, divided by the previous year's value. This did not yield a linear relationship either. Finally, we ploted the GDP per capita, but this did not yield a linear relationship either. To sum up, we couldn't find any linear relationship between yearly GDP and unemployment rate,","title":"GDP and Unemployment rate linear correlation"},{"location":"journey/clusters/","text":"Cluster Analysis This section talks about the clusters that we have built and used for the model. Need for clusters We wanted to forecast unemployment rate for all 401 Kreise of Germany. Of course, we could have create 401 independent time series models, one for each Kreis. However, this would mean that all models won't learn from the unemployment rate time series of other Kreise. We believed that some Kreise must be similar to each other, and can benefit from incorporating each other's data in the forecasting process. We used unsupervised classification methods to divide Kreise into clusters, based on 176 structural features collected during 2017-2018 for each Kreise. These clusters were later used in hierarchical time series models, and in VAR models. Type of Clusters We explored 4 different methods to cluster the Kreise Bundesland Each Kreise belongs to one out for 16 Bundeslands. Kreise that belong to the same Bundesland have a similar geographic location, and are also affected by the same decisions that are made on a Bundesland level. PCA & K-means We started with clustering using 169 numerical features (disregarding the 7 categorical features). First, we reduced the features dimension using PCA with 3 components. The first component explained 53.0% of the variance of the features, and represented mainly the population size features. The second component explained 11.4% of the variance of the features, and represented mainly the rural vs. city features. The third component explained 4.7% of the variance of the features, and represented mainly the economical features. Then, we used K-means to cluster the Kreise into 3 clusters based on the PCA features. tSNE We started with clustering using 169 numerical features (disregarding the 7 categorical features). First, we reduced the features dimension using tSNE with 3 components. Then, we used K-means to cluster the Kreise into 3 clusters based on the PCA features. K-modes To incorporate categorical features as well, we also tried K-modes classification on the original 176 features, both numerical and categorical. Cluster groups Bundesland Baden-W\u00fcrttemberg: Stuttgart, B\u00f6blingen, Esslingen, G\u00f6ppingen, Ludwigsburg, Rems-Murr-Kreis, Heilbronn, Heilbronn, Hohenlohekreis, Schw\u00e4bisch Hall, Main-Tauber-Kreis, Heidenheim, Ostalbkreis, Baden-Baden, Karlsruhe, Karlsruhe, Rastatt, Heidelberg, Mannheim, Neckar-Odenwald-Kreis, Rhein-Neckar-Kreis, Pforzheim, Calw, Enzkreis, Freudenstadt, Freiburg im Breisgau, Breisgau-Hochschwarzwald, Emmendingen, Ortenaukreis, Rottweil, Schwarzwald-Baar-Kreis, Tuttlingen, Konstanz, L\u00f6rrach, Waldshut, Reutlingen, T\u00fcbingen, Zollernalbkreis, Ulm, Alb-Donau-Kreis, Biberach, Bodenseekreis, Ravensburg, Sigmaringen Berlin: Berlin Brandenburg: Brandenburg an der Havel, Cottbus, Frankfurt (Oder), Potsdam, Barnim, Dahme-Spreewald, Elbe-Elster, Havelland, M\u00e4rkisch-Oderland, Oberhavel, Oberspreewald-Lausitz, Oder-Spree, Ostprignitz-Ruppin, Potsdam-Mittelmark, Prignitz, Spree-Nei\u00dfe, Teltow-Fl\u00e4ming, Uckermark Bremen: Bremen, Bremerhaven Freistaat Bayern: Ingolstadt, M\u00fcnchen, Rosenheim, Alt\u00f6tting, Berchtesgadener Land, Bad T\u00f6lz-Wolfratshausen, Dachau, Ebersberg, Eichst\u00e4tt, Erding, Freising, F\u00fcrstenfeldbruck, Garmisch-Partenkirchen, Landsberg am Lech, Miesbach, M\u00fchldorf a.Inn, M\u00fcnchen, Neuburg-Schrobenhausen, Pfaffenhofen a.d.Ilm, Rosenheim, Starnberg, Traunstein, Weilheim-Schongau, Landshut, Passau, Straubing, Deggendorf, Freyung-Grafenau, Kelheim, Landshut, Passau, Regen, Rottal-Inn, Straubing-Bogen, Dingolfing-Landau, Amberg, Regensburg, Weiden i.d.OPf., Amberg-Sulzbach, Cham, Neumarkt i.d.OPf., Neustadt a.d.Waldnaab, Regensburg, Schwandorf, Tirschenreuth, Bamberg, Bayreuth, Coburg, Hof, Bamberg, Bayreuth, Coburg, Forchheim, Hof, Kronach, Kulmbach, Lichtenfels, Wunsiedel i.Fichtelgebirge, Ansbach, Erlangen, F\u00fcrth, N\u00fcrnberg, Schwabach, Ansbach, Erlangen-H\u00f6chstadt, F\u00fcrth, N\u00fcrnberger Land, Neustadt a.d.Aisch-Bad Windsheim, Roth, Wei\u00dfenburg-Gunzenhausen, Aschaffenburg, Schweinfurt, W\u00fcrzburg, Aschaffenburg, Bad Kissingen, Rh\u00f6n-Grabfeld, Ha\u00dfberge, Kitzingen, Miltenberg, Main-Spessart, Schweinfurt, W\u00fcrzburg, Augsburg, Kaufbeuren, Kempten (Allg\u00e4u), Memmingen, Aichach-Friedberg, Augsburg, Dillingen a.d.Donau, G\u00fcnzburg, Neu-Ulm, Lindau (Bodensee), Ostallg\u00e4u, Unterallg\u00e4u, Donau-Ries, Oberallg\u00e4u Hamburg: Hamburg Hessen: Kreisfreie Stadt Darmstadt, Kreisfreie Stadt Frankfurt am Main, Kreisfreie Stadt Offenbach am Main, Landeshauptstadt Wiesbaden, Bergstra\u00dfe, Darmstadt-Dieburg, Gro\u00df-Gerau, Hochtaunus, Main-Kinzig, Main-Taunus, Odenwaldkreis, Offenbach, Rheingau-Taunus, Wetterau, Gie\u00dfen, Lahn-Dill, Limburg-Weilburg, Marburg-Biedenkopf, Vogelsberg, Kreisfreie Stadt Kassel, Fulda, Hersfeld-Rotenburg, Kassel, Schwalm-Eder, Waldeck-Frankenberg, Werra-Mei\u00dfner Mecklenburg-Vorpommern: Rostock, Hansestadt, Schwerin, Landeshauptstadt, Mecklenburgische Seenplatte, Landkreis Rostock, Vorpommern-R\u00fcgen, Nordwestmecklenburg, Vorpommern-Greifswald, Ludwigslust-Parchim Niedersachsen: Braunschweig, Salzgitter, Wolfsburg, Gifhorn, Goslar, Helmstedt, Northeim, Peine, Wolfenb\u00fcttel, G\u00f6ttingen, Hannover, Diepholz, Hameln-Pyrmont, Hildesheim, Holzminden, Nienburg/Weser, Schaumburg, Celle, Cuxhaven, Harburg, L\u00fcchow-Dannenberg, L\u00fcneburg, Osterholz, Rotenburg (W\u00fcmme), Heidekreis, Stade, Uelzen, Verden, Delmenhorst, Emden, Oldenburg, Osnabr\u00fcck, Wilhelmshaven, Ammerland, Aurich, Cloppenburg, Emsland, Friesland, Grafschaft Bentheim, Leer, Oldenburg, Osnabr\u00fcck, Vechta, Wesermarsch, Wittmund Nordrhein-Westfalen: D\u00fcsseldorf, Duisburg, Essen, Krefeld, M\u00f6nchengladbach, M\u00fclheim an der Ruhr, Oberhausen, Remscheid, Solingen, Wuppertal, Kleve, Mettmann, Rhein-Kreis Neuss, Viersen, Wesel, Bonn, K\u00f6ln, Leverkusen, Aachen, D\u00fcren, Rhein-Erft-Kreis, Euskirchen, Heinsberg, Oberbergischer Kreis, Rheinisch-Bergischer Kreis, Rhein-Sieg-Kreis, Bottrop, Gelsenkirchen, M\u00fcnster, Borken, Coesfeld, Recklinghausen, Steinfurt, Warendorf, Bielefeld, G\u00fctersloh, Herford, H\u00f6xter, Lippe, Minden-L\u00fcbbecke, Paderborn, Bochum, Dortmund, Hagen, Hamm, Herne, Ennepe-Ruhr-Kreis, Hochsauerlandkreis, M\u00e4rkischer Kreis, Olpe, Siegen-Wittgenstein, Soest, Unna Rheinland-Pfalz: Stadt Koblenz, Ahrweiler, Altenkirchen (Ww), Bad Kreuznach, Birkenfeld, Cochem-Zell, Mayen-Koblenz, Neuwied, Rhein-Hunsr\u00fcck-Kreis, Rhein-Lahn-Kreis, Westerwaldkreis, Stadt Trier, Bernkastel-Wittlich, Eifelkreis Bitburg-Pr\u00fcm, Vulkaneifel, Trier-Saarburg, Stadt Frankenthal (Pfalz), Stadt Kaiserslautern, Stadt Landau in der Pfalz, Stadt Ludwigshafen a. Rh., Stadt Mainz, Stadt Neustadt a.d. W., Stadt Pirmasens, Stadt Speyer, Stadt Worms, Stadt Zweibr\u00fccken, Alzey-Worms, Bad D\u00fcrkheim, Donnersbergkreis, Germersheim, Kaiserslautern, Kusel, S\u00fcdliche Weinstra\u00dfe, Rhein-Pfalz-Kreis, Mainz-Bingen, S\u00fcdwestpfalz Saarland: Regionalverband Saarbr\u00fccken, Landkreis Merzig-Wadern, Landkreis Neunkirchen, Landkreis Saarlouis, Saarpfalz-Kreis, Landkreis St. Wendel Sachsen: Chemnitz, Erzgebirgskreis, Mittelsachsen, Vogtlandkreis, Zwickau, Dresden, Bautzen, G\u00f6rlitz, Mei\u00dfen, S\u00e4chsische Schweiz-Osterzgebirge, Leipzig, Leipzig, Nordsachsen Sachsen-Anhalt: Dessau-Ro\u00dflau, Halle (Saale), Magdeburg, Altmarkkreis Salzwedel, Anhalt-Bitterfeld, B\u00f6rde, Burgenlandkreis, Harz, Jerichower Land, Mansfeld-S\u00fcdharz, Saalekreis, Salzlandkreis, Stendal, Wittenberg Schleswig-Holstein : Flensburg, Stadt, Kiel, Landeshauptstadt, L\u00fcbeck, Hansestadt, Neum\u00fcnster, Stadt, Dithmarschen, Herzogtum Lauenburg, Nordfriesland, Ostholstein, Pinneberg, Pl\u00f6n, Rendsburg-Eckernf\u00f6rde, Schleswig-Flensburg, Segeberg, Steinburg, Stormarn Th\u00fcringen: Erfurt, Gera, Jena, Suhl, Weimar, Eisenach, Eichsfeld, Nordhausen, Wartburgkreis, Unstrut-Hainich-Kreis, Kyffh\u00e4userkreis, Schmalkalden-Meiningen, Gotha, S\u00f6mmerda, Hildburghausen, Ilm-Kreis, Weimarer Land, Sonneberg, Saalfeld-Rudolstadt, Saale-Holzland-Kreis, Saale-Orla-Kreis, Greiz, Altenburger Land PCA & K-means Cluster 1: Flensburg, Stadt, Neum\u00fcnster, Stadt, Dithmarschen, Herzogtum Lauenburg, Nordfriesland, Ostholstein, Pinneberg, Pl\u00f6n, Rendsburg-Eckernf\u00f6rde, Schleswig-Flensburg, Segeberg, Steinburg, Stormarn, Salzgitter, Wolfsburg, Gifhorn, Goslar, Helmstedt, Northeim, Peine, Wolfenb\u00fcttel, G\u00f6ttingen, Diepholz, Hameln-Pyrmont, Hildesheim, Holzminden, Nienburg/Weser, Schaumburg, Celle, Cuxhaven, Harburg, L\u00fcchow-Dannenberg, L\u00fcneburg, Osterholz, Rotenburg (W\u00fcmme), Heidekreis, Stade, Uelzen, Verden, Delmenhorst, Emden, Oldenburg, Stadt, Osnabr\u00fcck, Stadt, Wilhelmshaven, Ammerland, Aurich, Cloppenburg, Emsland, Friesland, Grafschaft Bentheim, Leer, Oldenburg, Kreis, Osnabr\u00fcck, Kreis, Vechta, Wesermarsch, Wittmund, Bremerhaven, M\u00fclheim an der Ruhr, Remscheid, Solingen, Kleve, Viersen, Leverkusen, D\u00fcren, Euskirchen, Heinsberg, Oberbergischer Kreis, Rheinisch-Bergischer Kreis, Bottrop, Coesfeld, Warendorf, Herford, H\u00f6xter, Lippe, Minden-L\u00fcbbecke, Paderborn, Hagen, Hamm, Hochsauerlandkreis, Olpe, Siegen-Wittgenstein, Soest, Bergstra\u00dfe, Darmstadt-Dieburg, Hochtaunus, Main-Taunus, Odenwaldkreis, Rheingau-Taunus, Wetterau, Gie\u00dfen, Lahn-Dill, Limburg-Weilburg, Marburg-Biedenkopf, Vogelsberg, Fulda, Hersfeld-Rotenburg, Kassel, Schwalm-Eder, Waldeck-Frankenberg, Werra-Mei\u00dfner, Stadt Koblenz, Ahrweiler, Altenkirchen (Ww), Bad Kreuznach, Birkenfeld, Cochem-Zell, Mayen-Koblenz, Neuwied, Rhein-Hunsr\u00fcck-Kreis, Rhein-Lahn-Kreis, Westerwaldkreis, Stadt Trier, Bernkastel-Wittlich, Eifelkreis Bitburg-Pr\u00fcm, Vulkaneifel, Trier-Saarburg, Stadt Frankenthal (Pfalz), Stadt Kaiserslautern, Stadt Landau in der Pfalz, Stadt Neustadt a.d. W., Stadt Pirmasens, Stadt Speyer, Stadt Worms, Stadt Zweibr\u00fccken, Alzey-Worms, Bad D\u00fcrkheim, Donnersbergkreis, Germersheim, Kaiserslautern, Kusel, S\u00fcdliche Weinstra\u00dfe, Rhein-Pfalz-Kreis, Mainz-Bingen, S\u00fcdwestpfalz, G\u00f6ppingen, Heilbronn, Stadt, Heilbronn, Kreis, Hohenlohekreis, Schw\u00e4bisch Hall, Main-Tauber-Kreis, Heidenheim, Ostalbkreis, Baden-Baden, Rastatt, Neckar-Odenwald-Kreis, Pforzheim, Calw, Enzkreis, Freudenstadt, Breisgau-Hochschwarzwald, Emmendingen, Rottweil, Schwarzwald-Baar-Kreis, Tuttlingen, Konstanz, L\u00f6rrach, Waldshut, Reutlingen, T\u00fcbingen, Zollernalbkreis, Ulm, Alb-Donau-Kreis, Biberach, Bodenseekreis, Ravensburg, Sigmaringen, Ingolstadt, Alt\u00f6tting, Berchtesgadener Land, Bad T\u00f6lz-Wolfratshausen, Dachau, Ebersberg, Eichst\u00e4tt, Erding, Freising, F\u00fcrstenfeldbruck, Garmisch-Partenkirchen, Landsberg am Lech, Miesbach, M\u00fchldorf a.Inn, Neuburg-Schrobenhausen, Pfaffenhofen a.d.Ilm, Rosenheim, Kreis, Starnberg, Traunstein, Weilheim-Schongau, Landshut, Stadt, Passau, Stadt, Straubing, Deggendorf, Freyung-Grafenau, Kelheim, Landshut, Kreis, Passau, Kreis, Regen, Rottal-Inn, Straubing-Bogen, Dingolfing-Landau, Amberg, Weiden i.d.OPf., Amberg-Sulzbach, Cham, Neumarkt i.d.OPf., Neustadt a.d.Waldnaab, Regensburg, Kreis, Schwandorf, Tirschenreuth, Bamberg, Stadt, Bayreuth, Stadt, Coburg, Stadt, Hof, Stadt, Bamberg, Kreis, Bayreuth, Kreis, Coburg, Kreis, Forchheim, Hof, Kreis, Kronach, Kulmbach, Lichtenfels, Wunsiedel i.Fichtelgebirge, Ansbach, Stadt, Erlangen, F\u00fcrth, Stadt, Schwabach, Ansbach, Kreis, Erlangen-H\u00f6chstadt, F\u00fcrth, Kreis, N\u00fcrnberger Land, Neustadt a.d.Aisch-Bad Windsheim, Roth, Wei\u00dfenburg-Gunzenhausen, Aschaffenburg, Stadt, Schweinfurt, Stadt, W\u00fcrzburg, Stadt, Aschaffenburg, Kreis, Bad Kissingen, Rh\u00f6n-Grabfeld, Ha\u00dfberge, Kitzingen, Miltenberg, Main-Spessart, Schweinfurt, Kreis, W\u00fcrzburg, Kreis, Kaufbeuren, Kempten (Allg\u00e4u), Memmingen, Aichach-Friedberg, Augsburg, Kreis, Dillingen a.d.Donau, G\u00fcnzburg, Neu-Ulm, Lindau (Bodensee), Ostallg\u00e4u, Unterallg\u00e4u, Donau-Ries, Oberallg\u00e4u, Landkreis Merzig-Wadern, Landkreis Neunkirchen, Landkreis Saarlouis, Saarpfalz-Kreis, Landkreis St. Wendel, Brandenburg an der Havel, Cottbus, Frankfurt (Oder), Potsdam, Barnim, Dahme-Spreewald, Elbe-Elster, Havelland, M\u00e4rkisch-Oderland, Oberhavel, Oberspreewald-Lausitz, Oder-Spree, Ostprignitz-Ruppin, Potsdam-Mittelmark, Prignitz, Spree-Nei\u00dfe, Teltow-Fl\u00e4ming, Uckermark, Rostock, Hansestadt, Schwerin, Landeshauptstadt, Mecklenburgische Seenplatte, Landkreis Rostock, Vorpommern-R\u00fcgen, Nordwestmecklenburg, Vorpommern-Greifswald, Ludwigslust-Parchim, Chemnitz, Erzgebirgskreis, Mittelsachsen, Vogtlandkreis, Zwickau, Bautzen, G\u00f6rlitz, Mei\u00dfen, S\u00e4chsische Schweiz-Osterzgebirge, Leipzig, Kreis, Nordsachsen, Dessau-Ro\u00dflau, Altmarkkreis Salzwedel, Anhalt-Bitterfeld, B\u00f6rde, Burgenlandkreis, Harz, Jerichower Land, Mansfeld-S\u00fcdharz, Saalekreis, Salzlandkreis, Stendal, Wittenberg, Gera, Jena, Suhl, Weimar, Eisenach, Eichsfeld, Nordhausen, Wartburgkreis, Unstrut-Hainich-Kreis, Kyffh\u00e4userkreis, Schmalkalden-Meiningen, Gotha, S\u00f6mmerda, Hildburghausen, Ilm-Kreis, Weimarer Land, Sonneberg, Saalfeld-Rudolstadt, Saale-Holzland-Kreis, Saale-Orla-Kreis, Greiz, Altenburger Land Cluster 2: Hamburg, Berlin Cluster 3: Kiel, Landeshauptstadt, L\u00fcbeck, Hansestadt, Braunschweig, Hannover, Bremen, D\u00fcsseldorf, Duisburg, Essen, Krefeld, M\u00f6nchengladbach, Oberhausen, Wuppertal, Mettmann, Rhein-Kreis Neuss, Wesel, Bonn, K\u00f6ln, Aachen, Rhein-Erft-Kreis, Rhein-Sieg-Kreis, Gelsenkirchen, M\u00fcnster, Borken, Recklinghausen, Steinfurt, Bielefeld, G\u00fctersloh, Bochum, Dortmund, Herne, Ennepe-Ruhr-Kreis, M\u00e4rkischer Kreis, Unna, Kreisfreie Stadt Darmstadt, Kreisfreie Stadt Frankfurt am Main, Kreisfreie Stadt Offenbach am Main, Landeshauptstadt Wiesbaden, Gro\u00df-Gerau, Main-Kinzig, Offenbach, Kreisfreie Stadt Kassel, Stadt Ludwigshafen a. Rh., Stadt Mainz, Stuttgart, B\u00f6blingen, Esslingen, Ludwigsburg, Rems-Murr-Kreis, Karlsruhe, Stadt, Karlsruhe, Kreis, Heidelberg, Mannheim, Rhein-Neckar-Kreis, Freiburg im Breisgau, Ortenaukreis, M\u00fcnchen, Landeshauptstadt, Rosenheim, Stadt, M\u00fcnchen, Kreis, Regensburg, Stadt, N\u00fcrnberg, Augsburg, Stadt, Regionalverband Saarbr\u00fccken, Dresden, Leipzig, Stadt, Halle (Saale), Magdeburg, Erfurt tSNE & K-means Cluster 1: Dithmarschen, Herzogtum Lauenburg, Nordfriesland, Ostholstein, Pl\u00f6n, Schleswig-Flensburg, Steinburg, Goslar, Helmstedt, Northeim, Peine, Wolfenb\u00fcttel, Hameln-Pyrmont, Holzminden, Schaumburg, Celle, L\u00fcchow-Dannenberg, L\u00fcneburg, Osterholz, Heidekreis, Uelzen, Ammerland, Aurich, Friesland, Leer, Wesermarsch, Wittmund, Bottrop, H\u00f6xter, Odenwaldkreis, Vogelsberg, Hersfeld-Rotenburg, Schwalm-Eder, Waldeck-Frankenberg, Werra-Mei\u00dfner, Ahrweiler, Altenkirchen (Ww), Bad Kreuznach, Birkenfeld, Cochem-Zell, Rhein-Hunsr\u00fcck-Kreis, Rhein-Lahn-Kreis, Bernkastel-Wittlich, Eifelkreis Bitburg-Pr\u00fcm, Vulkaneifel, Trier-Saarburg, Stadt Zweibr\u00fccken, Bad D\u00fcrkheim, Donnersbergkreis, Kaiserslautern, Kusel, S\u00fcdliche Weinstra\u00dfe, S\u00fcdwestpfalz, Hohenlohekreis, Schw\u00e4bisch Hall, Main-Tauber-Kreis, Neckar-Odenwald-Kreis, Freudenstadt, Sigmaringen, Alt\u00f6tting, Berchtesgadener Land, Bad T\u00f6lz-Wolfratshausen, Eichst\u00e4tt, Erding, Garmisch-Partenkirchen, Landsberg am Lech, Miesbach, M\u00fchldorf a.Inn, Neuburg-Schrobenhausen, Pfaffenhofen a.d.Ilm, Traunstein, Deggendorf, Freyung-Grafenau, Kelheim, Landshut, Kreis, Passau, Kreis, Regen, Rottal-Inn, Straubing-Bogen, Dingolfing-Landau, Amberg-Sulzbach, Cham, Neumarkt i.d.OPf., Neustadt a.d.Waldnaab, Regensburg, Kreis, Schwandorf, Tirschenreuth, Bamberg, Kreis, Bayreuth, Kreis, Coburg, Kreis, Forchheim, Hof, Kreis, Kronach, Kulmbach, Lichtenfels, Wunsiedel i.Fichtelgebirge, Ansbach, Kreis, Neustadt a.d.Aisch-Bad Windsheim, Roth, Wei\u00dfenburg-Gunzenhausen, Bad Kissingen, Rh\u00f6n-Grabfeld, Ha\u00dfberge, Kitzingen, Main-Spessart, Schweinfurt, Kreis, Aichach-Friedberg, Dillingen a.d.Donau, G\u00fcnzburg, Ostallg\u00e4u, Unterallg\u00e4u, Donau-Ries, Oberallg\u00e4u, Landkreis Merzig-Wadern, Landkreis Neunkirchen, Landkreis Saarlouis, Saarpfalz-Kreis, Landkreis St. Wendel, Cottbus, Barnim, Dahme-Spreewald, Elbe-Elster, Havelland, M\u00e4rkisch-Oderland, Oberhavel, Oberspreewald-Lausitz, Oder-Spree, Ostprignitz-Ruppin, Potsdam-Mittelmark, Prignitz, Spree-Nei\u00dfe, Teltow-Fl\u00e4ming, Uckermark, Rostock, Hansestadt, Mecklenburgische Seenplatte, Landkreis Rostock, Vorpommern-R\u00fcgen, Nordwestmecklenburg, Vorpommern-Greifswald, Ludwigslust-Parchim, Chemnitz, Erzgebirgskreis, Mittelsachsen, Vogtlandkreis, Zwickau, Bautzen, G\u00f6rlitz, Mei\u00dfen, S\u00e4chsische Schweiz-Osterzgebirge, Leipzig, Kreis, Nordsachsen, Altmarkkreis Salzwedel, Anhalt-Bitterfeld, B\u00f6rde, Burgenlandkreis, Harz, Jerichower Land, Mansfeld-S\u00fcdharz, Saalekreis, Salzlandkreis, Stendal, Wittenberg, Eichsfeld, Nordhausen, Wartburgkreis, Unstrut-Hainich-Kreis, Kyffh\u00e4userkreis, Schmalkalden-Meiningen, Gotha, S\u00f6mmerda, Hildburghausen, Ilm-Kreis, Weimarer Land, Sonneberg, Saalfeld-Rudolstadt, Saale-Holzland-Kreis, Saale-Orla-Kreis, Greiz, Altenburger Land Cluster 2: Pinneberg, Rendsburg-Eckernf\u00f6rde, Segeberg, Stormarn, Hamburg, Gifhorn, G\u00f6ttingen, Hannover, Diepholz, Hildesheim, Nienburg/Weser, Cuxhaven, Harburg, Rotenburg (W\u00fcmme), Stade, Verden, Cloppenburg, Emsland, Grafschaft Bentheim, Oldenburg, Kreis, Osnabr\u00fcck, Kreis, Vechta, Kleve, Mettmann, Rhein-Kreis Neuss, Viersen, Wesel, K\u00f6ln, Aachen, D\u00fcren, Rhein-Erft-Kreis, Euskirchen, Heinsberg, Oberbergischer Kreis, Rheinisch-Bergischer Kreis, Rhein-Sieg-Kreis, Borken, Coesfeld, Recklinghausen, Steinfurt, Warendorf, G\u00fctersloh, Herford, Lippe, Minden-L\u00fcbbecke, Paderborn, Ennepe-Ruhr-Kreis, Hochsauerlandkreis, M\u00e4rkischer Kreis, Olpe, Siegen-Wittgenstein, Soest, Unna, Kreisfreie Stadt Frankfurt am Main, Kreisfreie Stadt Offenbach am Main, Bergstra\u00dfe, Darmstadt-Dieburg, Gro\u00df-Gerau, Hochtaunus, Main-Kinzig, Main-Taunus, Offenbach, Rheingau-Taunus, Wetterau, Gie\u00dfen, Lahn-Dill, Limburg-Weilburg, Marburg-Biedenkopf, Fulda, Kassel, Mayen-Koblenz, Neuwied, Westerwaldkreis, Alzey-Worms, Germersheim, Rhein-Pfalz-Kreis, Mainz-Bingen, Stuttgart, B\u00f6blingen, Esslingen, G\u00f6ppingen, Ludwigsburg, Rems-Murr-Kreis, Heilbronn, Kreis, Heidenheim, Ostalbkreis, Baden-Baden, Karlsruhe, Kreis, Rastatt, Rhein-Neckar-Kreis, Pforzheim, Calw, Enzkreis, Breisgau-Hochschwarzwald, Emmendingen, Ortenaukreis, Rottweil, Schwarzwald-Baar-Kreis, Tuttlingen, Konstanz, L\u00f6rrach, Waldshut, Reutlingen, T\u00fcbingen, Zollernalbkreis, Alb-Donau-Kreis, Biberach, Bodenseekreis, Ravensburg, M\u00fcnchen, Landeshauptstadt, Rosenheim, Stadt, Dachau, Ebersberg, Freising, F\u00fcrstenfeldbruck, M\u00fcnchen, Kreis, Rosenheim, Kreis, Starnberg, Weilheim-Schongau, Erlangen-H\u00f6chstadt, F\u00fcrth, Kreis, N\u00fcrnberger Land, Aschaffenburg, Kreis, Miltenberg, W\u00fcrzburg, Kreis, Augsburg, Kreis, Neu-Ulm, Regionalverband Saarbr\u00fccken, Berlin Cluster 3: Flensburg, Stadt, Kiel, Landeshauptstadt, L\u00fcbeck, Hansestadt, Neum\u00fcnster, Stadt, Braunschweig, Salzgitter, Wolfsburg, Delmenhorst, Emden, Oldenburg, Stadt, Osnabr\u00fcck, Stadt, Wilhelmshaven, Bremen, Bremerhaven, D\u00fcsseldorf, Duisburg, Essen, Krefeld, M\u00f6nchengladbach, M\u00fclheim an der Ruhr, Oberhausen, Remscheid, Solingen, Wuppertal, Bonn, Leverkusen, Gelsenkirchen, M\u00fcnster, Bielefeld, Bochum, Dortmund, Hagen, Hamm, Herne, Kreisfreie Stadt Darmstadt, Landeshauptstadt Wiesbaden, Kreisfreie Stadt Kassel, Stadt Koblenz, Stadt Trier, Stadt Frankenthal (Pfalz), Stadt Kaiserslautern, Stadt Landau in der Pfalz, Stadt Ludwigshafen a. Rh., Stadt Mainz, Stadt Neustadt a.d. W., Stadt Pirmasens, Stadt Speyer, Stadt Worms, Heilbronn, Stadt, Karlsruhe, Stadt, Heidelberg, Mannheim, Freiburg im Breisgau, Ulm, Ingolstadt, Landshut, Stadt, Passau, Stadt, Straubing, Amberg, Regensburg, Stadt, Weiden i.d.OPf., Bamberg, Stadt, Bayreuth, Stadt, Coburg, Stadt, Hof, Stadt, Ansbach, Stadt, Erlangen, F\u00fcrth, Stadt, N\u00fcrnberg, Schwabach, Aschaffenburg, Stadt, Schweinfurt, Stadt, W\u00fcrzburg, Stadt, Augsburg, Stadt, Kaufbeuren, Kempten (Allg\u00e4u), Memmingen, Lindau (Bodensee), Brandenburg an der Havel, Frankfurt (Oder), Potsdam, Schwerin, Landeshauptstadt, Dresden, Leipzig, Stadt, Dessau-Ro\u00dflau, Halle (Saale), Magdeburg, Erfurt, Gera, Jena, Suhl, Weimar, Eisenach K-modes Cluster 1: Neum\u00fcnster, Stadt, Herzogtum Lauenburg, Ostholstein, Rendsburg-Eckernf\u00f6rde, Schleswig-Flensburg, Segeberg, Wolfenb\u00fcttel, Hameln-Pyrmont, Nienburg/Weser, Celle, Cuxhaven, Rotenburg (W\u00fcmme), Stade, Verden, Delmenhorst, Emden, Wilhelmshaven, Aurich, Cloppenburg, Emsland, Grafschaft Bentheim, Leer, Vechta, Warendorf, H\u00f6xter, Hochsauerlandkreis, Olpe, Marburg-Biedenkopf, Fulda, Hersfeld-Rotenburg, Schwalm-Eder, Stadt Koblenz, Ahrweiler, Bad Kreuznach, Rhein-Hunsr\u00fcck-Kreis, Bernkastel-Wittlich, Eifelkreis Bitburg-Pr\u00fcm, Trier-Saarburg, Donnersbergkreis, Kusel, S\u00fcdwestpfalz, Hohenlohekreis, Schw\u00e4bisch Hall, Main-Tauber-Kreis, Neckar-Odenwald-Kreis, Freudenstadt, Waldshut, Alb-Donau-Kreis, Biberach, Sigmaringen, Ingolstadt, Alt\u00f6tting, Berchtesgadener Land, Bad T\u00f6lz-Wolfratshausen, Eichst\u00e4tt, Erding, Garmisch-Partenkirchen, Landsberg am Lech, Miesbach, M\u00fchldorf a.Inn, Neuburg-Schrobenhausen, Pfaffenhofen a.d.Ilm, Rosenheim, Kreis, Traunstein, Weilheim-Schongau, Landshut, Stadt, Passau, Stadt, Straubing, Deggendorf, Kelheim, Landshut, Kreis, Passau, Kreis, Regen, Rottal-Inn, Straubing-Bogen, Dingolfing-Landau, Neumarkt i.d.OPf., Regensburg, Kreis, Schwandorf, Bamberg, Stadt, Bayreuth, Stadt, Coburg, Stadt, Hof, Stadt, Bamberg, Kreis, Bayreuth, Kreis, Coburg, Kreis, Forchheim, Hof, Kreis, Kronach, Lichtenfels, Ansbach, Stadt, Ansbach, Kreis, Roth, Wei\u00dfenburg-Gunzenhausen, Schweinfurt, Stadt, Rh\u00f6n-Grabfeld, Kitzingen, Miltenberg, Main-Spessart, Schweinfurt, Kreis, Kempten (Allg\u00e4u), Memmingen, Aichach-Friedberg, Dillingen a.d.Donau, G\u00fcnzburg, Ostallg\u00e4u, Unterallg\u00e4u, Donau-Ries, Brandenburg an der Havel, Cottbus, Nordwestmecklenburg, Anhalt-Bitterfeld, Burgenlandkreis, Altenburger Land Cluster 2: Flensburg, Stadt, Dithmarschen, Nordfriesland, Pl\u00f6n, Steinburg, Gifhorn, Goslar, Helmstedt, Northeim, Holzminden, L\u00fcchow-Dannenberg, L\u00fcneburg, Heidekreis, Uelzen, Wesermarsch, Wittmund, Vogelsberg, Waldeck-Frankenberg, Werra-Mei\u00dfner, Birkenfeld, Cochem-Zell, Vulkaneifel, Freyung-Grafenau, Amberg, Weiden i.d.OPf., Amberg-Sulzbach, Cham, Neustadt a.d.Waldnaab, Tirschenreuth, Kulmbach, Wunsiedel i.Fichtelgebirge, Neustadt a.d.Aisch-Bad Windsheim, Bad Kissingen, Ha\u00dfberge, Kaufbeuren, Oberallg\u00e4u, Frankfurt (Oder), Potsdam, Barnim, Dahme-Spreewald, Elbe-Elster, Havelland, M\u00e4rkisch-Oderland, Oberhavel, Oberspreewald-Lausitz, Oder-Spree, Ostprignitz-Ruppin, Potsdam-Mittelmark, Prignitz, Spree-Nei\u00dfe, Teltow-Fl\u00e4ming, Uckermark, Schwerin, Landeshauptstadt, Mecklenburgische Seenplatte, Landkreis Rostock, Vorpommern-R\u00fcgen, Vorpommern-Greifswald, Ludwigslust-Parchim, Erzgebirgskreis, Mittelsachsen, Vogtlandkreis, Zwickau, Bautzen, G\u00f6rlitz, Mei\u00dfen, S\u00e4chsische Schweiz-Osterzgebirge, Nordsachsen, Dessau-Ro\u00dflau, Magdeburg, Altmarkkreis Salzwedel, B\u00f6rde, Harz, Jerichower Land, Mansfeld-S\u00fcdharz, Saalekreis, Salzlandkreis, Stendal, Wittenberg, Erfurt, Gera, Suhl, Eisenach, Eichsfeld, Nordhausen, Wartburgkreis, Unstrut-Hainich-Kreis, Kyffh\u00e4userkreis, Schmalkalden-Meiningen, Gotha, S\u00f6mmerda, Hildburghausen, Ilm-Kreis, Sonneberg, Saalfeld-Rudolstadt, Saale-Holzland-Kreis, Saale-Orla-Kreis, Greiz Cluster 3: Kiel, Landeshauptstadt, L\u00fcbeck, Hansestadt, Pinneberg, Stormarn, Hamburg, Braunschweig, Salzgitter, Wolfsburg, Peine, G\u00f6ttingen, Hannover, Diepholz, Hildesheim, Schaumburg, Harburg, Osterholz, Oldenburg, Stadt, Osnabr\u00fcck, Stadt, Ammerland, Friesland, Oldenburg, Kreis, Osnabr\u00fcck, Kreis, Bremen, Bremerhaven, D\u00fcsseldorf, Duisburg, Essen, Krefeld, M\u00f6nchengladbach, M\u00fclheim an der Ruhr, Oberhausen, Remscheid, Solingen, Wuppertal, Kleve, Mettmann, Rhein-Kreis Neuss, Viersen, Wesel, Bonn, K\u00f6ln, Leverkusen, Aachen, D\u00fcren, Rhein-Erft-Kreis, Euskirchen, Heinsberg, Oberbergischer Kreis, Rheinisch-Bergischer Kreis, Rhein-Sieg-Kreis, Bottrop, Gelsenkirchen, M\u00fcnster, Borken, Coesfeld, Recklinghausen, Steinfurt, Bielefeld, G\u00fctersloh, Herford, Lippe, Minden-L\u00fcbbecke, Paderborn, Bochum, Dortmund, Hagen, Hamm, Herne, Ennepe-Ruhr-Kreis, M\u00e4rkischer Kreis, Siegen-Wittgenstein, Soest, Unna, Kreisfreie Stadt Darmstadt, Kreisfreie Stadt Frankfurt am Main, Kreisfreie Stadt Offenbach am Main, Landeshauptstadt Wiesbaden, Bergstra\u00dfe, Darmstadt-Dieburg, Gro\u00df-Gerau, Hochtaunus, Main-Kinzig, Main-Taunus, Odenwaldkreis, Offenbach, Rheingau-Taunus, Wetterau, Gie\u00dfen, Lahn-Dill, Limburg-Weilburg, Kreisfreie Stadt Kassel, Kassel, Altenkirchen (Ww), Mayen-Koblenz, Neuwied, Rhein-Lahn-Kreis, Westerwaldkreis, Stadt Trier, Stadt Frankenthal (Pfalz), Stadt Kaiserslautern, Stadt Landau in der Pfalz, Stadt Ludwigshafen a. Rh., Stadt Mainz, Stadt Neustadt a.d. W., Stadt Pirmasens, Stadt Speyer, Stadt Worms, Stadt Zweibr\u00fccken, Alzey-Worms, Bad D\u00fcrkheim, Germersheim, Kaiserslautern, S\u00fcdliche Weinstra\u00dfe, Rhein-Pfalz-Kreis, Mainz-Bingen, Stuttgart, B\u00f6blingen, Esslingen, G\u00f6ppingen, Ludwigsburg, Rems-Murr-Kreis, Heilbronn, Stadt, Heilbronn, Kreis, Heidenheim, Ostalbkreis, Baden-Baden, Karlsruhe, Stadt, Karlsruhe, Kreis, Rastatt, Heidelberg, Mannheim, Rhein-Neckar-Kreis, Pforzheim, Calw, Enzkreis, Freiburg im Breisgau, Breisgau-Hochschwarzwald, Emmendingen, Ortenaukreis, Rottweil, Schwarzwald-Baar-Kreis, Tuttlingen, Konstanz, L\u00f6rrach, Reutlingen, T\u00fcbingen, Zollernalbkreis, Ulm, Bodenseekreis, Ravensburg, M\u00fcnchen, Landeshauptstadt, Rosenheim, Stadt, Dachau, Ebersberg, Freising, F\u00fcrstenfeldbruck, M\u00fcnchen, Kreis, Starnberg, Regensburg, Stadt, Erlangen, F\u00fcrth, Stadt, N\u00fcrnberg, Schwabach, Erlangen-H\u00f6chstadt, F\u00fcrth, Kreis, N\u00fcrnberger Land, Aschaffenburg, Stadt, W\u00fcrzburg, Stadt, Aschaffenburg, Kreis, W\u00fcrzburg, Kreis, Augsburg, Stadt, Augsburg, Kreis, Neu-Ulm, Lindau (Bodensee), Regionalverband Saarbr\u00fccken, Landkreis Merzig-Wadern, Landkreis Neunkirchen, Landkreis Saarlouis, Saarpfalz-Kreis, Landkreis St. Wendel, Berlin, Rostock, Hansestadt, Chemnitz, Dresden, Leipzig, Stadt, Leipzig, Kreis, Halle (Saale), Jena, Weimar, Weimarer Land","title":"Clusters"},{"location":"journey/clusters/#cluster-analysis","text":"This section talks about the clusters that we have built and used for the model.","title":"Cluster Analysis"},{"location":"journey/clusters/#need-for-clusters","text":"We wanted to forecast unemployment rate for all 401 Kreise of Germany. Of course, we could have create 401 independent time series models, one for each Kreis. However, this would mean that all models won't learn from the unemployment rate time series of other Kreise. We believed that some Kreise must be similar to each other, and can benefit from incorporating each other's data in the forecasting process. We used unsupervised classification methods to divide Kreise into clusters, based on 176 structural features collected during 2017-2018 for each Kreise. These clusters were later used in hierarchical time series models, and in VAR models.","title":"Need for clusters"},{"location":"journey/clusters/#type-of-clusters","text":"We explored 4 different methods to cluster the Kreise","title":"Type of Clusters"},{"location":"journey/clusters/#bundesland","text":"Each Kreise belongs to one out for 16 Bundeslands. Kreise that belong to the same Bundesland have a similar geographic location, and are also affected by the same decisions that are made on a Bundesland level.","title":"Bundesland"},{"location":"journey/clusters/#pca-k-means","text":"We started with clustering using 169 numerical features (disregarding the 7 categorical features). First, we reduced the features dimension using PCA with 3 components. The first component explained 53.0% of the variance of the features, and represented mainly the population size features. The second component explained 11.4% of the variance of the features, and represented mainly the rural vs. city features. The third component explained 4.7% of the variance of the features, and represented mainly the economical features. Then, we used K-means to cluster the Kreise into 3 clusters based on the PCA features.","title":"PCA &amp; K-means"},{"location":"journey/clusters/#tsne","text":"We started with clustering using 169 numerical features (disregarding the 7 categorical features). First, we reduced the features dimension using tSNE with 3 components. Then, we used K-means to cluster the Kreise into 3 clusters based on the PCA features.","title":"tSNE"},{"location":"journey/clusters/#k-modes","text":"To incorporate categorical features as well, we also tried K-modes classification on the original 176 features, both numerical and categorical.","title":"K-modes"},{"location":"journey/clusters/#cluster-groups","text":"Bundesland Baden-W\u00fcrttemberg: Stuttgart, B\u00f6blingen, Esslingen, G\u00f6ppingen, Ludwigsburg, Rems-Murr-Kreis, Heilbronn, Heilbronn, Hohenlohekreis, Schw\u00e4bisch Hall, Main-Tauber-Kreis, Heidenheim, Ostalbkreis, Baden-Baden, Karlsruhe, Karlsruhe, Rastatt, Heidelberg, Mannheim, Neckar-Odenwald-Kreis, Rhein-Neckar-Kreis, Pforzheim, Calw, Enzkreis, Freudenstadt, Freiburg im Breisgau, Breisgau-Hochschwarzwald, Emmendingen, Ortenaukreis, Rottweil, Schwarzwald-Baar-Kreis, Tuttlingen, Konstanz, L\u00f6rrach, Waldshut, Reutlingen, T\u00fcbingen, Zollernalbkreis, Ulm, Alb-Donau-Kreis, Biberach, Bodenseekreis, Ravensburg, Sigmaringen Berlin: Berlin Brandenburg: Brandenburg an der Havel, Cottbus, Frankfurt (Oder), Potsdam, Barnim, Dahme-Spreewald, Elbe-Elster, Havelland, M\u00e4rkisch-Oderland, Oberhavel, Oberspreewald-Lausitz, Oder-Spree, Ostprignitz-Ruppin, Potsdam-Mittelmark, Prignitz, Spree-Nei\u00dfe, Teltow-Fl\u00e4ming, Uckermark Bremen: Bremen, Bremerhaven Freistaat Bayern: Ingolstadt, M\u00fcnchen, Rosenheim, Alt\u00f6tting, Berchtesgadener Land, Bad T\u00f6lz-Wolfratshausen, Dachau, Ebersberg, Eichst\u00e4tt, Erding, Freising, F\u00fcrstenfeldbruck, Garmisch-Partenkirchen, Landsberg am Lech, Miesbach, M\u00fchldorf a.Inn, M\u00fcnchen, Neuburg-Schrobenhausen, Pfaffenhofen a.d.Ilm, Rosenheim, Starnberg, Traunstein, Weilheim-Schongau, Landshut, Passau, Straubing, Deggendorf, Freyung-Grafenau, Kelheim, Landshut, Passau, Regen, Rottal-Inn, Straubing-Bogen, Dingolfing-Landau, Amberg, Regensburg, Weiden i.d.OPf., Amberg-Sulzbach, Cham, Neumarkt i.d.OPf., Neustadt a.d.Waldnaab, Regensburg, Schwandorf, Tirschenreuth, Bamberg, Bayreuth, Coburg, Hof, Bamberg, Bayreuth, Coburg, Forchheim, Hof, Kronach, Kulmbach, Lichtenfels, Wunsiedel i.Fichtelgebirge, Ansbach, Erlangen, F\u00fcrth, N\u00fcrnberg, Schwabach, Ansbach, Erlangen-H\u00f6chstadt, F\u00fcrth, N\u00fcrnberger Land, Neustadt a.d.Aisch-Bad Windsheim, Roth, Wei\u00dfenburg-Gunzenhausen, Aschaffenburg, Schweinfurt, W\u00fcrzburg, Aschaffenburg, Bad Kissingen, Rh\u00f6n-Grabfeld, Ha\u00dfberge, Kitzingen, Miltenberg, Main-Spessart, Schweinfurt, W\u00fcrzburg, Augsburg, Kaufbeuren, Kempten (Allg\u00e4u), Memmingen, Aichach-Friedberg, Augsburg, Dillingen a.d.Donau, G\u00fcnzburg, Neu-Ulm, Lindau (Bodensee), Ostallg\u00e4u, Unterallg\u00e4u, Donau-Ries, Oberallg\u00e4u Hamburg: Hamburg Hessen: Kreisfreie Stadt Darmstadt, Kreisfreie Stadt Frankfurt am Main, Kreisfreie Stadt Offenbach am Main, Landeshauptstadt Wiesbaden, Bergstra\u00dfe, Darmstadt-Dieburg, Gro\u00df-Gerau, Hochtaunus, Main-Kinzig, Main-Taunus, Odenwaldkreis, Offenbach, Rheingau-Taunus, Wetterau, Gie\u00dfen, Lahn-Dill, Limburg-Weilburg, Marburg-Biedenkopf, Vogelsberg, Kreisfreie Stadt Kassel, Fulda, Hersfeld-Rotenburg, Kassel, Schwalm-Eder, Waldeck-Frankenberg, Werra-Mei\u00dfner Mecklenburg-Vorpommern: Rostock, Hansestadt, Schwerin, Landeshauptstadt, Mecklenburgische Seenplatte, Landkreis Rostock, Vorpommern-R\u00fcgen, Nordwestmecklenburg, Vorpommern-Greifswald, Ludwigslust-Parchim Niedersachsen: Braunschweig, Salzgitter, Wolfsburg, Gifhorn, Goslar, Helmstedt, Northeim, Peine, Wolfenb\u00fcttel, G\u00f6ttingen, Hannover, Diepholz, Hameln-Pyrmont, Hildesheim, Holzminden, Nienburg/Weser, Schaumburg, Celle, Cuxhaven, Harburg, L\u00fcchow-Dannenberg, L\u00fcneburg, Osterholz, Rotenburg (W\u00fcmme), Heidekreis, Stade, Uelzen, Verden, Delmenhorst, Emden, Oldenburg, Osnabr\u00fcck, Wilhelmshaven, Ammerland, Aurich, Cloppenburg, Emsland, Friesland, Grafschaft Bentheim, Leer, Oldenburg, Osnabr\u00fcck, Vechta, Wesermarsch, Wittmund Nordrhein-Westfalen: D\u00fcsseldorf, Duisburg, Essen, Krefeld, M\u00f6nchengladbach, M\u00fclheim an der Ruhr, Oberhausen, Remscheid, Solingen, Wuppertal, Kleve, Mettmann, Rhein-Kreis Neuss, Viersen, Wesel, Bonn, K\u00f6ln, Leverkusen, Aachen, D\u00fcren, Rhein-Erft-Kreis, Euskirchen, Heinsberg, Oberbergischer Kreis, Rheinisch-Bergischer Kreis, Rhein-Sieg-Kreis, Bottrop, Gelsenkirchen, M\u00fcnster, Borken, Coesfeld, Recklinghausen, Steinfurt, Warendorf, Bielefeld, G\u00fctersloh, Herford, H\u00f6xter, Lippe, Minden-L\u00fcbbecke, Paderborn, Bochum, Dortmund, Hagen, Hamm, Herne, Ennepe-Ruhr-Kreis, Hochsauerlandkreis, M\u00e4rkischer Kreis, Olpe, Siegen-Wittgenstein, Soest, Unna Rheinland-Pfalz: Stadt Koblenz, Ahrweiler, Altenkirchen (Ww), Bad Kreuznach, Birkenfeld, Cochem-Zell, Mayen-Koblenz, Neuwied, Rhein-Hunsr\u00fcck-Kreis, Rhein-Lahn-Kreis, Westerwaldkreis, Stadt Trier, Bernkastel-Wittlich, Eifelkreis Bitburg-Pr\u00fcm, Vulkaneifel, Trier-Saarburg, Stadt Frankenthal (Pfalz), Stadt Kaiserslautern, Stadt Landau in der Pfalz, Stadt Ludwigshafen a. Rh., Stadt Mainz, Stadt Neustadt a.d. W., Stadt Pirmasens, Stadt Speyer, Stadt Worms, Stadt Zweibr\u00fccken, Alzey-Worms, Bad D\u00fcrkheim, Donnersbergkreis, Germersheim, Kaiserslautern, Kusel, S\u00fcdliche Weinstra\u00dfe, Rhein-Pfalz-Kreis, Mainz-Bingen, S\u00fcdwestpfalz Saarland: Regionalverband Saarbr\u00fccken, Landkreis Merzig-Wadern, Landkreis Neunkirchen, Landkreis Saarlouis, Saarpfalz-Kreis, Landkreis St. Wendel Sachsen: Chemnitz, Erzgebirgskreis, Mittelsachsen, Vogtlandkreis, Zwickau, Dresden, Bautzen, G\u00f6rlitz, Mei\u00dfen, S\u00e4chsische Schweiz-Osterzgebirge, Leipzig, Leipzig, Nordsachsen Sachsen-Anhalt: Dessau-Ro\u00dflau, Halle (Saale), Magdeburg, Altmarkkreis Salzwedel, Anhalt-Bitterfeld, B\u00f6rde, Burgenlandkreis, Harz, Jerichower Land, Mansfeld-S\u00fcdharz, Saalekreis, Salzlandkreis, Stendal, Wittenberg Schleswig-Holstein : Flensburg, Stadt, Kiel, Landeshauptstadt, L\u00fcbeck, Hansestadt, Neum\u00fcnster, Stadt, Dithmarschen, Herzogtum Lauenburg, Nordfriesland, Ostholstein, Pinneberg, Pl\u00f6n, Rendsburg-Eckernf\u00f6rde, Schleswig-Flensburg, Segeberg, Steinburg, Stormarn Th\u00fcringen: Erfurt, Gera, Jena, Suhl, Weimar, Eisenach, Eichsfeld, Nordhausen, Wartburgkreis, Unstrut-Hainich-Kreis, Kyffh\u00e4userkreis, Schmalkalden-Meiningen, Gotha, S\u00f6mmerda, Hildburghausen, Ilm-Kreis, Weimarer Land, Sonneberg, Saalfeld-Rudolstadt, Saale-Holzland-Kreis, Saale-Orla-Kreis, Greiz, Altenburger Land PCA & K-means Cluster 1: Flensburg, Stadt, Neum\u00fcnster, Stadt, Dithmarschen, Herzogtum Lauenburg, Nordfriesland, Ostholstein, Pinneberg, Pl\u00f6n, Rendsburg-Eckernf\u00f6rde, Schleswig-Flensburg, Segeberg, Steinburg, Stormarn, Salzgitter, Wolfsburg, Gifhorn, Goslar, Helmstedt, Northeim, Peine, Wolfenb\u00fcttel, G\u00f6ttingen, Diepholz, Hameln-Pyrmont, Hildesheim, Holzminden, Nienburg/Weser, Schaumburg, Celle, Cuxhaven, Harburg, L\u00fcchow-Dannenberg, L\u00fcneburg, Osterholz, Rotenburg (W\u00fcmme), Heidekreis, Stade, Uelzen, Verden, Delmenhorst, Emden, Oldenburg, Stadt, Osnabr\u00fcck, Stadt, Wilhelmshaven, Ammerland, Aurich, Cloppenburg, Emsland, Friesland, Grafschaft Bentheim, Leer, Oldenburg, Kreis, Osnabr\u00fcck, Kreis, Vechta, Wesermarsch, Wittmund, Bremerhaven, M\u00fclheim an der Ruhr, Remscheid, Solingen, Kleve, Viersen, Leverkusen, D\u00fcren, Euskirchen, Heinsberg, Oberbergischer Kreis, Rheinisch-Bergischer Kreis, Bottrop, Coesfeld, Warendorf, Herford, H\u00f6xter, Lippe, Minden-L\u00fcbbecke, Paderborn, Hagen, Hamm, Hochsauerlandkreis, Olpe, Siegen-Wittgenstein, Soest, Bergstra\u00dfe, Darmstadt-Dieburg, Hochtaunus, Main-Taunus, Odenwaldkreis, Rheingau-Taunus, Wetterau, Gie\u00dfen, Lahn-Dill, Limburg-Weilburg, Marburg-Biedenkopf, Vogelsberg, Fulda, Hersfeld-Rotenburg, Kassel, Schwalm-Eder, Waldeck-Frankenberg, Werra-Mei\u00dfner, Stadt Koblenz, Ahrweiler, Altenkirchen (Ww), Bad Kreuznach, Birkenfeld, Cochem-Zell, Mayen-Koblenz, Neuwied, Rhein-Hunsr\u00fcck-Kreis, Rhein-Lahn-Kreis, Westerwaldkreis, Stadt Trier, Bernkastel-Wittlich, Eifelkreis Bitburg-Pr\u00fcm, Vulkaneifel, Trier-Saarburg, Stadt Frankenthal (Pfalz), Stadt Kaiserslautern, Stadt Landau in der Pfalz, Stadt Neustadt a.d. W., Stadt Pirmasens, Stadt Speyer, Stadt Worms, Stadt Zweibr\u00fccken, Alzey-Worms, Bad D\u00fcrkheim, Donnersbergkreis, Germersheim, Kaiserslautern, Kusel, S\u00fcdliche Weinstra\u00dfe, Rhein-Pfalz-Kreis, Mainz-Bingen, S\u00fcdwestpfalz, G\u00f6ppingen, Heilbronn, Stadt, Heilbronn, Kreis, Hohenlohekreis, Schw\u00e4bisch Hall, Main-Tauber-Kreis, Heidenheim, Ostalbkreis, Baden-Baden, Rastatt, Neckar-Odenwald-Kreis, Pforzheim, Calw, Enzkreis, Freudenstadt, Breisgau-Hochschwarzwald, Emmendingen, Rottweil, Schwarzwald-Baar-Kreis, Tuttlingen, Konstanz, L\u00f6rrach, Waldshut, Reutlingen, T\u00fcbingen, Zollernalbkreis, Ulm, Alb-Donau-Kreis, Biberach, Bodenseekreis, Ravensburg, Sigmaringen, Ingolstadt, Alt\u00f6tting, Berchtesgadener Land, Bad T\u00f6lz-Wolfratshausen, Dachau, Ebersberg, Eichst\u00e4tt, Erding, Freising, F\u00fcrstenfeldbruck, Garmisch-Partenkirchen, Landsberg am Lech, Miesbach, M\u00fchldorf a.Inn, Neuburg-Schrobenhausen, Pfaffenhofen a.d.Ilm, Rosenheim, Kreis, Starnberg, Traunstein, Weilheim-Schongau, Landshut, Stadt, Passau, Stadt, Straubing, Deggendorf, Freyung-Grafenau, Kelheim, Landshut, Kreis, Passau, Kreis, Regen, Rottal-Inn, Straubing-Bogen, Dingolfing-Landau, Amberg, Weiden i.d.OPf., Amberg-Sulzbach, Cham, Neumarkt i.d.OPf., Neustadt a.d.Waldnaab, Regensburg, Kreis, Schwandorf, Tirschenreuth, Bamberg, Stadt, Bayreuth, Stadt, Coburg, Stadt, Hof, Stadt, Bamberg, Kreis, Bayreuth, Kreis, Coburg, Kreis, Forchheim, Hof, Kreis, Kronach, Kulmbach, Lichtenfels, Wunsiedel i.Fichtelgebirge, Ansbach, Stadt, Erlangen, F\u00fcrth, Stadt, Schwabach, Ansbach, Kreis, Erlangen-H\u00f6chstadt, F\u00fcrth, Kreis, N\u00fcrnberger Land, Neustadt a.d.Aisch-Bad Windsheim, Roth, Wei\u00dfenburg-Gunzenhausen, Aschaffenburg, Stadt, Schweinfurt, Stadt, W\u00fcrzburg, Stadt, Aschaffenburg, Kreis, Bad Kissingen, Rh\u00f6n-Grabfeld, Ha\u00dfberge, Kitzingen, Miltenberg, Main-Spessart, Schweinfurt, Kreis, W\u00fcrzburg, Kreis, Kaufbeuren, Kempten (Allg\u00e4u), Memmingen, Aichach-Friedberg, Augsburg, Kreis, Dillingen a.d.Donau, G\u00fcnzburg, Neu-Ulm, Lindau (Bodensee), Ostallg\u00e4u, Unterallg\u00e4u, Donau-Ries, Oberallg\u00e4u, Landkreis Merzig-Wadern, Landkreis Neunkirchen, Landkreis Saarlouis, Saarpfalz-Kreis, Landkreis St. Wendel, Brandenburg an der Havel, Cottbus, Frankfurt (Oder), Potsdam, Barnim, Dahme-Spreewald, Elbe-Elster, Havelland, M\u00e4rkisch-Oderland, Oberhavel, Oberspreewald-Lausitz, Oder-Spree, Ostprignitz-Ruppin, Potsdam-Mittelmark, Prignitz, Spree-Nei\u00dfe, Teltow-Fl\u00e4ming, Uckermark, Rostock, Hansestadt, Schwerin, Landeshauptstadt, Mecklenburgische Seenplatte, Landkreis Rostock, Vorpommern-R\u00fcgen, Nordwestmecklenburg, Vorpommern-Greifswald, Ludwigslust-Parchim, Chemnitz, Erzgebirgskreis, Mittelsachsen, Vogtlandkreis, Zwickau, Bautzen, G\u00f6rlitz, Mei\u00dfen, S\u00e4chsische Schweiz-Osterzgebirge, Leipzig, Kreis, Nordsachsen, Dessau-Ro\u00dflau, Altmarkkreis Salzwedel, Anhalt-Bitterfeld, B\u00f6rde, Burgenlandkreis, Harz, Jerichower Land, Mansfeld-S\u00fcdharz, Saalekreis, Salzlandkreis, Stendal, Wittenberg, Gera, Jena, Suhl, Weimar, Eisenach, Eichsfeld, Nordhausen, Wartburgkreis, Unstrut-Hainich-Kreis, Kyffh\u00e4userkreis, Schmalkalden-Meiningen, Gotha, S\u00f6mmerda, Hildburghausen, Ilm-Kreis, Weimarer Land, Sonneberg, Saalfeld-Rudolstadt, Saale-Holzland-Kreis, Saale-Orla-Kreis, Greiz, Altenburger Land Cluster 2: Hamburg, Berlin Cluster 3: Kiel, Landeshauptstadt, L\u00fcbeck, Hansestadt, Braunschweig, Hannover, Bremen, D\u00fcsseldorf, Duisburg, Essen, Krefeld, M\u00f6nchengladbach, Oberhausen, Wuppertal, Mettmann, Rhein-Kreis Neuss, Wesel, Bonn, K\u00f6ln, Aachen, Rhein-Erft-Kreis, Rhein-Sieg-Kreis, Gelsenkirchen, M\u00fcnster, Borken, Recklinghausen, Steinfurt, Bielefeld, G\u00fctersloh, Bochum, Dortmund, Herne, Ennepe-Ruhr-Kreis, M\u00e4rkischer Kreis, Unna, Kreisfreie Stadt Darmstadt, Kreisfreie Stadt Frankfurt am Main, Kreisfreie Stadt Offenbach am Main, Landeshauptstadt Wiesbaden, Gro\u00df-Gerau, Main-Kinzig, Offenbach, Kreisfreie Stadt Kassel, Stadt Ludwigshafen a. Rh., Stadt Mainz, Stuttgart, B\u00f6blingen, Esslingen, Ludwigsburg, Rems-Murr-Kreis, Karlsruhe, Stadt, Karlsruhe, Kreis, Heidelberg, Mannheim, Rhein-Neckar-Kreis, Freiburg im Breisgau, Ortenaukreis, M\u00fcnchen, Landeshauptstadt, Rosenheim, Stadt, M\u00fcnchen, Kreis, Regensburg, Stadt, N\u00fcrnberg, Augsburg, Stadt, Regionalverband Saarbr\u00fccken, Dresden, Leipzig, Stadt, Halle (Saale), Magdeburg, Erfurt tSNE & K-means Cluster 1: Dithmarschen, Herzogtum Lauenburg, Nordfriesland, Ostholstein, Pl\u00f6n, Schleswig-Flensburg, Steinburg, Goslar, Helmstedt, Northeim, Peine, Wolfenb\u00fcttel, Hameln-Pyrmont, Holzminden, Schaumburg, Celle, L\u00fcchow-Dannenberg, L\u00fcneburg, Osterholz, Heidekreis, Uelzen, Ammerland, Aurich, Friesland, Leer, Wesermarsch, Wittmund, Bottrop, H\u00f6xter, Odenwaldkreis, Vogelsberg, Hersfeld-Rotenburg, Schwalm-Eder, Waldeck-Frankenberg, Werra-Mei\u00dfner, Ahrweiler, Altenkirchen (Ww), Bad Kreuznach, Birkenfeld, Cochem-Zell, Rhein-Hunsr\u00fcck-Kreis, Rhein-Lahn-Kreis, Bernkastel-Wittlich, Eifelkreis Bitburg-Pr\u00fcm, Vulkaneifel, Trier-Saarburg, Stadt Zweibr\u00fccken, Bad D\u00fcrkheim, Donnersbergkreis, Kaiserslautern, Kusel, S\u00fcdliche Weinstra\u00dfe, S\u00fcdwestpfalz, Hohenlohekreis, Schw\u00e4bisch Hall, Main-Tauber-Kreis, Neckar-Odenwald-Kreis, Freudenstadt, Sigmaringen, Alt\u00f6tting, Berchtesgadener Land, Bad T\u00f6lz-Wolfratshausen, Eichst\u00e4tt, Erding, Garmisch-Partenkirchen, Landsberg am Lech, Miesbach, M\u00fchldorf a.Inn, Neuburg-Schrobenhausen, Pfaffenhofen a.d.Ilm, Traunstein, Deggendorf, Freyung-Grafenau, Kelheim, Landshut, Kreis, Passau, Kreis, Regen, Rottal-Inn, Straubing-Bogen, Dingolfing-Landau, Amberg-Sulzbach, Cham, Neumarkt i.d.OPf., Neustadt a.d.Waldnaab, Regensburg, Kreis, Schwandorf, Tirschenreuth, Bamberg, Kreis, Bayreuth, Kreis, Coburg, Kreis, Forchheim, Hof, Kreis, Kronach, Kulmbach, Lichtenfels, Wunsiedel i.Fichtelgebirge, Ansbach, Kreis, Neustadt a.d.Aisch-Bad Windsheim, Roth, Wei\u00dfenburg-Gunzenhausen, Bad Kissingen, Rh\u00f6n-Grabfeld, Ha\u00dfberge, Kitzingen, Main-Spessart, Schweinfurt, Kreis, Aichach-Friedberg, Dillingen a.d.Donau, G\u00fcnzburg, Ostallg\u00e4u, Unterallg\u00e4u, Donau-Ries, Oberallg\u00e4u, Landkreis Merzig-Wadern, Landkreis Neunkirchen, Landkreis Saarlouis, Saarpfalz-Kreis, Landkreis St. Wendel, Cottbus, Barnim, Dahme-Spreewald, Elbe-Elster, Havelland, M\u00e4rkisch-Oderland, Oberhavel, Oberspreewald-Lausitz, Oder-Spree, Ostprignitz-Ruppin, Potsdam-Mittelmark, Prignitz, Spree-Nei\u00dfe, Teltow-Fl\u00e4ming, Uckermark, Rostock, Hansestadt, Mecklenburgische Seenplatte, Landkreis Rostock, Vorpommern-R\u00fcgen, Nordwestmecklenburg, Vorpommern-Greifswald, Ludwigslust-Parchim, Chemnitz, Erzgebirgskreis, Mittelsachsen, Vogtlandkreis, Zwickau, Bautzen, G\u00f6rlitz, Mei\u00dfen, S\u00e4chsische Schweiz-Osterzgebirge, Leipzig, Kreis, Nordsachsen, Altmarkkreis Salzwedel, Anhalt-Bitterfeld, B\u00f6rde, Burgenlandkreis, Harz, Jerichower Land, Mansfeld-S\u00fcdharz, Saalekreis, Salzlandkreis, Stendal, Wittenberg, Eichsfeld, Nordhausen, Wartburgkreis, Unstrut-Hainich-Kreis, Kyffh\u00e4userkreis, Schmalkalden-Meiningen, Gotha, S\u00f6mmerda, Hildburghausen, Ilm-Kreis, Weimarer Land, Sonneberg, Saalfeld-Rudolstadt, Saale-Holzland-Kreis, Saale-Orla-Kreis, Greiz, Altenburger Land Cluster 2: Pinneberg, Rendsburg-Eckernf\u00f6rde, Segeberg, Stormarn, Hamburg, Gifhorn, G\u00f6ttingen, Hannover, Diepholz, Hildesheim, Nienburg/Weser, Cuxhaven, Harburg, Rotenburg (W\u00fcmme), Stade, Verden, Cloppenburg, Emsland, Grafschaft Bentheim, Oldenburg, Kreis, Osnabr\u00fcck, Kreis, Vechta, Kleve, Mettmann, Rhein-Kreis Neuss, Viersen, Wesel, K\u00f6ln, Aachen, D\u00fcren, Rhein-Erft-Kreis, Euskirchen, Heinsberg, Oberbergischer Kreis, Rheinisch-Bergischer Kreis, Rhein-Sieg-Kreis, Borken, Coesfeld, Recklinghausen, Steinfurt, Warendorf, G\u00fctersloh, Herford, Lippe, Minden-L\u00fcbbecke, Paderborn, Ennepe-Ruhr-Kreis, Hochsauerlandkreis, M\u00e4rkischer Kreis, Olpe, Siegen-Wittgenstein, Soest, Unna, Kreisfreie Stadt Frankfurt am Main, Kreisfreie Stadt Offenbach am Main, Bergstra\u00dfe, Darmstadt-Dieburg, Gro\u00df-Gerau, Hochtaunus, Main-Kinzig, Main-Taunus, Offenbach, Rheingau-Taunus, Wetterau, Gie\u00dfen, Lahn-Dill, Limburg-Weilburg, Marburg-Biedenkopf, Fulda, Kassel, Mayen-Koblenz, Neuwied, Westerwaldkreis, Alzey-Worms, Germersheim, Rhein-Pfalz-Kreis, Mainz-Bingen, Stuttgart, B\u00f6blingen, Esslingen, G\u00f6ppingen, Ludwigsburg, Rems-Murr-Kreis, Heilbronn, Kreis, Heidenheim, Ostalbkreis, Baden-Baden, Karlsruhe, Kreis, Rastatt, Rhein-Neckar-Kreis, Pforzheim, Calw, Enzkreis, Breisgau-Hochschwarzwald, Emmendingen, Ortenaukreis, Rottweil, Schwarzwald-Baar-Kreis, Tuttlingen, Konstanz, L\u00f6rrach, Waldshut, Reutlingen, T\u00fcbingen, Zollernalbkreis, Alb-Donau-Kreis, Biberach, Bodenseekreis, Ravensburg, M\u00fcnchen, Landeshauptstadt, Rosenheim, Stadt, Dachau, Ebersberg, Freising, F\u00fcrstenfeldbruck, M\u00fcnchen, Kreis, Rosenheim, Kreis, Starnberg, Weilheim-Schongau, Erlangen-H\u00f6chstadt, F\u00fcrth, Kreis, N\u00fcrnberger Land, Aschaffenburg, Kreis, Miltenberg, W\u00fcrzburg, Kreis, Augsburg, Kreis, Neu-Ulm, Regionalverband Saarbr\u00fccken, Berlin Cluster 3: Flensburg, Stadt, Kiel, Landeshauptstadt, L\u00fcbeck, Hansestadt, Neum\u00fcnster, Stadt, Braunschweig, Salzgitter, Wolfsburg, Delmenhorst, Emden, Oldenburg, Stadt, Osnabr\u00fcck, Stadt, Wilhelmshaven, Bremen, Bremerhaven, D\u00fcsseldorf, Duisburg, Essen, Krefeld, M\u00f6nchengladbach, M\u00fclheim an der Ruhr, Oberhausen, Remscheid, Solingen, Wuppertal, Bonn, Leverkusen, Gelsenkirchen, M\u00fcnster, Bielefeld, Bochum, Dortmund, Hagen, Hamm, Herne, Kreisfreie Stadt Darmstadt, Landeshauptstadt Wiesbaden, Kreisfreie Stadt Kassel, Stadt Koblenz, Stadt Trier, Stadt Frankenthal (Pfalz), Stadt Kaiserslautern, Stadt Landau in der Pfalz, Stadt Ludwigshafen a. Rh., Stadt Mainz, Stadt Neustadt a.d. W., Stadt Pirmasens, Stadt Speyer, Stadt Worms, Heilbronn, Stadt, Karlsruhe, Stadt, Heidelberg, Mannheim, Freiburg im Breisgau, Ulm, Ingolstadt, Landshut, Stadt, Passau, Stadt, Straubing, Amberg, Regensburg, Stadt, Weiden i.d.OPf., Bamberg, Stadt, Bayreuth, Stadt, Coburg, Stadt, Hof, Stadt, Ansbach, Stadt, Erlangen, F\u00fcrth, Stadt, N\u00fcrnberg, Schwabach, Aschaffenburg, Stadt, Schweinfurt, Stadt, W\u00fcrzburg, Stadt, Augsburg, Stadt, Kaufbeuren, Kempten (Allg\u00e4u), Memmingen, Lindau (Bodensee), Brandenburg an der Havel, Frankfurt (Oder), Potsdam, Schwerin, Landeshauptstadt, Dresden, Leipzig, Stadt, Dessau-Ro\u00dflau, Halle (Saale), Magdeburg, Erfurt, Gera, Jena, Suhl, Weimar, Eisenach K-modes Cluster 1: Neum\u00fcnster, Stadt, Herzogtum Lauenburg, Ostholstein, Rendsburg-Eckernf\u00f6rde, Schleswig-Flensburg, Segeberg, Wolfenb\u00fcttel, Hameln-Pyrmont, Nienburg/Weser, Celle, Cuxhaven, Rotenburg (W\u00fcmme), Stade, Verden, Delmenhorst, Emden, Wilhelmshaven, Aurich, Cloppenburg, Emsland, Grafschaft Bentheim, Leer, Vechta, Warendorf, H\u00f6xter, Hochsauerlandkreis, Olpe, Marburg-Biedenkopf, Fulda, Hersfeld-Rotenburg, Schwalm-Eder, Stadt Koblenz, Ahrweiler, Bad Kreuznach, Rhein-Hunsr\u00fcck-Kreis, Bernkastel-Wittlich, Eifelkreis Bitburg-Pr\u00fcm, Trier-Saarburg, Donnersbergkreis, Kusel, S\u00fcdwestpfalz, Hohenlohekreis, Schw\u00e4bisch Hall, Main-Tauber-Kreis, Neckar-Odenwald-Kreis, Freudenstadt, Waldshut, Alb-Donau-Kreis, Biberach, Sigmaringen, Ingolstadt, Alt\u00f6tting, Berchtesgadener Land, Bad T\u00f6lz-Wolfratshausen, Eichst\u00e4tt, Erding, Garmisch-Partenkirchen, Landsberg am Lech, Miesbach, M\u00fchldorf a.Inn, Neuburg-Schrobenhausen, Pfaffenhofen a.d.Ilm, Rosenheim, Kreis, Traunstein, Weilheim-Schongau, Landshut, Stadt, Passau, Stadt, Straubing, Deggendorf, Kelheim, Landshut, Kreis, Passau, Kreis, Regen, Rottal-Inn, Straubing-Bogen, Dingolfing-Landau, Neumarkt i.d.OPf., Regensburg, Kreis, Schwandorf, Bamberg, Stadt, Bayreuth, Stadt, Coburg, Stadt, Hof, Stadt, Bamberg, Kreis, Bayreuth, Kreis, Coburg, Kreis, Forchheim, Hof, Kreis, Kronach, Lichtenfels, Ansbach, Stadt, Ansbach, Kreis, Roth, Wei\u00dfenburg-Gunzenhausen, Schweinfurt, Stadt, Rh\u00f6n-Grabfeld, Kitzingen, Miltenberg, Main-Spessart, Schweinfurt, Kreis, Kempten (Allg\u00e4u), Memmingen, Aichach-Friedberg, Dillingen a.d.Donau, G\u00fcnzburg, Ostallg\u00e4u, Unterallg\u00e4u, Donau-Ries, Brandenburg an der Havel, Cottbus, Nordwestmecklenburg, Anhalt-Bitterfeld, Burgenlandkreis, Altenburger Land Cluster 2: Flensburg, Stadt, Dithmarschen, Nordfriesland, Pl\u00f6n, Steinburg, Gifhorn, Goslar, Helmstedt, Northeim, Holzminden, L\u00fcchow-Dannenberg, L\u00fcneburg, Heidekreis, Uelzen, Wesermarsch, Wittmund, Vogelsberg, Waldeck-Frankenberg, Werra-Mei\u00dfner, Birkenfeld, Cochem-Zell, Vulkaneifel, Freyung-Grafenau, Amberg, Weiden i.d.OPf., Amberg-Sulzbach, Cham, Neustadt a.d.Waldnaab, Tirschenreuth, Kulmbach, Wunsiedel i.Fichtelgebirge, Neustadt a.d.Aisch-Bad Windsheim, Bad Kissingen, Ha\u00dfberge, Kaufbeuren, Oberallg\u00e4u, Frankfurt (Oder), Potsdam, Barnim, Dahme-Spreewald, Elbe-Elster, Havelland, M\u00e4rkisch-Oderland, Oberhavel, Oberspreewald-Lausitz, Oder-Spree, Ostprignitz-Ruppin, Potsdam-Mittelmark, Prignitz, Spree-Nei\u00dfe, Teltow-Fl\u00e4ming, Uckermark, Schwerin, Landeshauptstadt, Mecklenburgische Seenplatte, Landkreis Rostock, Vorpommern-R\u00fcgen, Vorpommern-Greifswald, Ludwigslust-Parchim, Erzgebirgskreis, Mittelsachsen, Vogtlandkreis, Zwickau, Bautzen, G\u00f6rlitz, Mei\u00dfen, S\u00e4chsische Schweiz-Osterzgebirge, Nordsachsen, Dessau-Ro\u00dflau, Magdeburg, Altmarkkreis Salzwedel, B\u00f6rde, Harz, Jerichower Land, Mansfeld-S\u00fcdharz, Saalekreis, Salzlandkreis, Stendal, Wittenberg, Erfurt, Gera, Suhl, Eisenach, Eichsfeld, Nordhausen, Wartburgkreis, Unstrut-Hainich-Kreis, Kyffh\u00e4userkreis, Schmalkalden-Meiningen, Gotha, S\u00f6mmerda, Hildburghausen, Ilm-Kreis, Sonneberg, Saalfeld-Rudolstadt, Saale-Holzland-Kreis, Saale-Orla-Kreis, Greiz Cluster 3: Kiel, Landeshauptstadt, L\u00fcbeck, Hansestadt, Pinneberg, Stormarn, Hamburg, Braunschweig, Salzgitter, Wolfsburg, Peine, G\u00f6ttingen, Hannover, Diepholz, Hildesheim, Schaumburg, Harburg, Osterholz, Oldenburg, Stadt, Osnabr\u00fcck, Stadt, Ammerland, Friesland, Oldenburg, Kreis, Osnabr\u00fcck, Kreis, Bremen, Bremerhaven, D\u00fcsseldorf, Duisburg, Essen, Krefeld, M\u00f6nchengladbach, M\u00fclheim an der Ruhr, Oberhausen, Remscheid, Solingen, Wuppertal, Kleve, Mettmann, Rhein-Kreis Neuss, Viersen, Wesel, Bonn, K\u00f6ln, Leverkusen, Aachen, D\u00fcren, Rhein-Erft-Kreis, Euskirchen, Heinsberg, Oberbergischer Kreis, Rheinisch-Bergischer Kreis, Rhein-Sieg-Kreis, Bottrop, Gelsenkirchen, M\u00fcnster, Borken, Coesfeld, Recklinghausen, Steinfurt, Bielefeld, G\u00fctersloh, Herford, Lippe, Minden-L\u00fcbbecke, Paderborn, Bochum, Dortmund, Hagen, Hamm, Herne, Ennepe-Ruhr-Kreis, M\u00e4rkischer Kreis, Siegen-Wittgenstein, Soest, Unna, Kreisfreie Stadt Darmstadt, Kreisfreie Stadt Frankfurt am Main, Kreisfreie Stadt Offenbach am Main, Landeshauptstadt Wiesbaden, Bergstra\u00dfe, Darmstadt-Dieburg, Gro\u00df-Gerau, Hochtaunus, Main-Kinzig, Main-Taunus, Odenwaldkreis, Offenbach, Rheingau-Taunus, Wetterau, Gie\u00dfen, Lahn-Dill, Limburg-Weilburg, Kreisfreie Stadt Kassel, Kassel, Altenkirchen (Ww), Mayen-Koblenz, Neuwied, Rhein-Lahn-Kreis, Westerwaldkreis, Stadt Trier, Stadt Frankenthal (Pfalz), Stadt Kaiserslautern, Stadt Landau in der Pfalz, Stadt Ludwigshafen a. Rh., Stadt Mainz, Stadt Neustadt a.d. W., Stadt Pirmasens, Stadt Speyer, Stadt Worms, Stadt Zweibr\u00fccken, Alzey-Worms, Bad D\u00fcrkheim, Germersheim, Kaiserslautern, S\u00fcdliche Weinstra\u00dfe, Rhein-Pfalz-Kreis, Mainz-Bingen, Stuttgart, B\u00f6blingen, Esslingen, G\u00f6ppingen, Ludwigsburg, Rems-Murr-Kreis, Heilbronn, Stadt, Heilbronn, Kreis, Heidenheim, Ostalbkreis, Baden-Baden, Karlsruhe, Stadt, Karlsruhe, Kreis, Rastatt, Heidelberg, Mannheim, Rhein-Neckar-Kreis, Pforzheim, Calw, Enzkreis, Freiburg im Breisgau, Breisgau-Hochschwarzwald, Emmendingen, Ortenaukreis, Rottweil, Schwarzwald-Baar-Kreis, Tuttlingen, Konstanz, L\u00f6rrach, Reutlingen, T\u00fcbingen, Zollernalbkreis, Ulm, Bodenseekreis, Ravensburg, M\u00fcnchen, Landeshauptstadt, Rosenheim, Stadt, Dachau, Ebersberg, Freising, F\u00fcrstenfeldbruck, M\u00fcnchen, Kreis, Starnberg, Regensburg, Stadt, Erlangen, F\u00fcrth, Stadt, N\u00fcrnberg, Schwabach, Erlangen-H\u00f6chstadt, F\u00fcrth, Kreis, N\u00fcrnberger Land, Aschaffenburg, Stadt, W\u00fcrzburg, Stadt, Aschaffenburg, Kreis, W\u00fcrzburg, Kreis, Augsburg, Stadt, Augsburg, Kreis, Neu-Ulm, Lindau (Bodensee), Regionalverband Saarbr\u00fccken, Landkreis Merzig-Wadern, Landkreis Neunkirchen, Landkreis Saarlouis, Saarpfalz-Kreis, Landkreis St. Wendel, Berlin, Rostock, Hansestadt, Chemnitz, Dresden, Leipzig, Stadt, Leipzig, Kreis, Halle (Saale), Jena, Weimar, Weimarer Land","title":"Cluster groups"},{"location":"journey/covid19/","text":"Covid19 restrictions We wanted to estimate the causal effects of decisions on unemployment rate, but because these decisions were not random, we couldn't just compare the groups. Therefore, we wanted to use IPTW to balance the groups. The idea is to give a higher weight to observations that got the decision they were not \"supposed\" to get. However, this did not work. For some of the decisions (e.g. closing restaurants), all kreise made the same decisions simultaneously, therefore we can't estimate the effect of these decisions. For other decisions (e.g. curfew), not all kreise made the same decisions simultaneously, but the kreise were perfectly separated. For example, weights were calculated using logistic regression, for predicting of a kreis that will force curfew, based on all other features available, but almost each weight was 0 or 1. All kreise in one group were fundamentally different then all kreise in the other, thus even the weights couldn\u2019t help. Therefore, the causal effects can't be estimated.","title":"Covid19 restrictions"},{"location":"journey/covid19/#covid19-restrictions","text":"We wanted to estimate the causal effects of decisions on unemployment rate, but because these decisions were not random, we couldn't just compare the groups. Therefore, we wanted to use IPTW to balance the groups. The idea is to give a higher weight to observations that got the decision they were not \"supposed\" to get. However, this did not work. For some of the decisions (e.g. closing restaurants), all kreise made the same decisions simultaneously, therefore we can't estimate the effect of these decisions. For other decisions (e.g. curfew), not all kreise made the same decisions simultaneously, but the kreise were perfectly separated. For example, weights were calculated using logistic regression, for predicting of a kreis that will force curfew, based on all other features available, but almost each weight was 0 or 1. All kreise in one group were fundamentally different then all kreise in the other, thus even the weights couldn\u2019t help. Therefore, the causal effects can't be estimated.","title":"Covid19 restrictions"},{"location":"journey/models/","text":"Model Descriptions This section talks about the various models that we have built and tested. It documents the various models which worked well and also the models which did not work well. Vector Autoregression Vector Autoregression (VAR) is a forecasting algorithm that can be used when two or more time series influence each other. That is, the relationship between the time series involved is bi-directional. Model Introduction Vector Autoregression (VAR) is a multivariate forecasting algorithm that is used when two or more time series influence each other. It is considered as an Autoregressive model because, each variable (Time Series) is modeled as a function of the past values, that is the predictors are nothing but the lags (time delayed value) of the series.The primary difference between VAR and other Autoregressive (AR) modesl is that these models are uni-directional, where, the predictors influence the Y and not vice-versa. Whereas, VAR is bi-directional. That is, the variables influence each other. Typical AR Model: Future value only depends on the past values of that series. VAR Model: Future values of one series depends on the past value of the same series and the parallel series Training Method The training is done using the clusters that were developed based on the stationary data. The cluster development method has been elucidated within the cluster section . The intuition behind VAR based cluster methods is that the Kreis in each cluster move together in terms of the unemployment rate and affect each other. The regional clusters are made using Bundesland and does not perform as well as the custom clusters which were created using statistical data. Since VAR learns from parallel series, the kreis in each cluster affect each other's unemployment rate within the same cluster. Prophet Prophet is a procedure for forecasting time series data based on an additive model where non-linear trends are fit with yearly, weekly, and daily seasonality, plus holiday effects. It works best with time series that have strong seasonal effects and several seasons of historical data. Prophet is robust to missing data and shifts in the trend, and typically handles outliers well. We fitted the Prophet model and did a grid search to chose the hyper-parameters. However, it did not perform well for our data. SARIMA Autoregressive Integrated Moving Average, or ARIMA, is one of the most widely used forecasting methods for univariate time series data forecasting. Although the method can handle data with a trend, it does not support time series with a seasonal component. An extension to ARIMA that supports the direct modeling of the seasonal component of the series is called SARIMA. The hyperparameters were tuned for all the time series (time series of unemployment of each kreis) using grid search individually. Most of the series converged best for the hyperparameters p:1, d:1, q:1, s_p:1, s_d:0, s_q:1 with each season containing a year. So these hyperparameters were chosen for all the 401 models that were trained for all the kreise. Neural network We explored multiple architectures including fully-connected, simple RNN, LSTM, GRU. Fully-Connected networks with the inputs as the unemployment rates of past 12 months always constintently performed better than other architectures. The best Fully Connected Neural Networks was of the shape: 32, 16, 8, 4, 1 with ReLu for the activation function for all but the last layer. Hierarchical Time Series Hierarchical time series model is a model that utilized the hierarchy in the data. It generates forecasts for each individual time series, but takes into account the relationships within the hierarchy. In our case, we considered the hierarchy of the different clusters explained in the cluster section . We forecasted using different models, - SARIMA - Auto Arima - Prophet We aggregated using different methods, - Top-Down - AHP - PHA\u200b - Bottom-Up\u200b - WLSS Unfortunately, the bottom up approach was best, which means that the hierarchy does not add any useful information. References [1] https://www.machinelearningplus.com/time-series/vector-autoregression-examples-python/ [2] https://facebook.github.io/prophet/docs/quick_start.html [3] https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.html [4] https://machinelearningmastery.com/sarima-for-time-series-forecasting-in-python/ [5] https://keras.io/guides/sequential_model/ [6] https://scikit-hts.readthedocs.io/en/latest/index.html","title":"Models"},{"location":"journey/models/#model-descriptions","text":"This section talks about the various models that we have built and tested. It documents the various models which worked well and also the models which did not work well.","title":"Model Descriptions"},{"location":"journey/models/#vector-autoregression","text":"Vector Autoregression (VAR) is a forecasting algorithm that can be used when two or more time series influence each other. That is, the relationship between the time series involved is bi-directional. Model Introduction Vector Autoregression (VAR) is a multivariate forecasting algorithm that is used when two or more time series influence each other. It is considered as an Autoregressive model because, each variable (Time Series) is modeled as a function of the past values, that is the predictors are nothing but the lags (time delayed value) of the series.The primary difference between VAR and other Autoregressive (AR) modesl is that these models are uni-directional, where, the predictors influence the Y and not vice-versa. Whereas, VAR is bi-directional. That is, the variables influence each other. Typical AR Model: Future value only depends on the past values of that series. VAR Model: Future values of one series depends on the past value of the same series and the parallel series Training Method The training is done using the clusters that were developed based on the stationary data. The cluster development method has been elucidated within the cluster section . The intuition behind VAR based cluster methods is that the Kreis in each cluster move together in terms of the unemployment rate and affect each other. The regional clusters are made using Bundesland and does not perform as well as the custom clusters which were created using statistical data. Since VAR learns from parallel series, the kreis in each cluster affect each other's unemployment rate within the same cluster.","title":"Vector Autoregression"},{"location":"journey/models/#prophet","text":"Prophet is a procedure for forecasting time series data based on an additive model where non-linear trends are fit with yearly, weekly, and daily seasonality, plus holiday effects. It works best with time series that have strong seasonal effects and several seasons of historical data. Prophet is robust to missing data and shifts in the trend, and typically handles outliers well. We fitted the Prophet model and did a grid search to chose the hyper-parameters. However, it did not perform well for our data.","title":"Prophet"},{"location":"journey/models/#sarima","text":"Autoregressive Integrated Moving Average, or ARIMA, is one of the most widely used forecasting methods for univariate time series data forecasting. Although the method can handle data with a trend, it does not support time series with a seasonal component. An extension to ARIMA that supports the direct modeling of the seasonal component of the series is called SARIMA. The hyperparameters were tuned for all the time series (time series of unemployment of each kreis) using grid search individually. Most of the series converged best for the hyperparameters p:1, d:1, q:1, s_p:1, s_d:0, s_q:1 with each season containing a year. So these hyperparameters were chosen for all the 401 models that were trained for all the kreise.","title":"SARIMA"},{"location":"journey/models/#neural-network","text":"We explored multiple architectures including fully-connected, simple RNN, LSTM, GRU. Fully-Connected networks with the inputs as the unemployment rates of past 12 months always constintently performed better than other architectures. The best Fully Connected Neural Networks was of the shape: 32, 16, 8, 4, 1 with ReLu for the activation function for all but the last layer.","title":"Neural network"},{"location":"journey/models/#hierarchical-time-series","text":"Hierarchical time series model is a model that utilized the hierarchy in the data. It generates forecasts for each individual time series, but takes into account the relationships within the hierarchy. In our case, we considered the hierarchy of the different clusters explained in the cluster section . We forecasted using different models, - SARIMA - Auto Arima - Prophet We aggregated using different methods, - Top-Down - AHP - PHA\u200b - Bottom-Up\u200b - WLSS Unfortunately, the bottom up approach was best, which means that the hierarchy does not add any useful information.","title":"Hierarchical Time Series"},{"location":"journey/models/#references","text":"[1] https://www.machinelearningplus.com/time-series/vector-autoregression-examples-python/ [2] https://facebook.github.io/prophet/docs/quick_start.html [3] https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.html [4] https://machinelearningmastery.com/sarima-for-time-series-forecasting-in-python/ [5] https://keras.io/guides/sequential_model/ [6] https://scikit-hts.readthedocs.io/en/latest/index.html","title":"References"},{"location":"start/quick/","text":"Quick Access Welcome to the BMWi tool documentation. This is a tool developed to forecast the Kreis level unemployment rate for the next quarter as well as perform various analyses like the prediction error analysis or Kreis vulnerability detection using structural data. There are different things you can explore depending on the use case. The common ones are mentioned below: If you want understand the step-by-step procedure to get fresh predictions, head to the Step-By-Step Guide . To set up the tool on your local machine, follow the installation guide . If you want to get more details about the data cleaning, analysis and the machine learning models that we built, head over to our journey section. To know more about the team which developed this application, check out the Team Page .","title":"Quick Access"},{"location":"start/quick/#quick-access","text":"Welcome to the BMWi tool documentation. This is a tool developed to forecast the Kreis level unemployment rate for the next quarter as well as perform various analyses like the prediction error analysis or Kreis vulnerability detection using structural data. There are different things you can explore depending on the use case. The common ones are mentioned below: If you want understand the step-by-step procedure to get fresh predictions, head to the Step-By-Step Guide . To set up the tool on your local machine, follow the installation guide . If you want to get more details about the data cleaning, analysis and the machine learning models that we built, head over to our journey section. To know more about the team which developed this application, check out the Team Page .","title":"Quick Access"},{"location":"start/start/","text":"Start Here mermaid.initialize({startOnLoad:true}); mermaidAPI.initialize({ securityLevel: 'loose' }); \ud83e\udd2f First-time Users | \ud83d\ude0a Experienced Users | \ud83d\ude05 Quick Access | \ud83e\udd14 Technical Users Pro Tip : Clicking on the blue boxes in the flowchart brings you to the documentation page for that specific step. First-time Users This is a simplified version of the user workflow. You can find the detailed user workflow here. When you open the tool, the first page you see is the Home page. Your prediction journey starts on the Data Prep page. There, you upload the data, and do necessary preprocessing that would then feed into the model. Click here to download an Excel file containing data till May 2021. This Excel file contains the format of the input that our tool was tested on. Once you \"confirm\" the preprocessed data on the Data Prep page, you can go to the Predictions page. The data which was uploaded on the data prep page is automatically loaded on the predictions page. The predictions may take a while to run. The prediction results are cached, which means it would run faster the second time you try to predict the same data. The Visualizations page includes line plots and map visualizations to quickly understand the prediction results, e.g. which kreis has the highest unemployment rate, whether the trend for that kreis is going up or down. The Rankings page contains kreis-level and grouped rankings of unemployment rates and their percentage changes. The Error Analysis page would be automatically loaded with the prediction results. This page helps you look closer into which kreise were harder to predict, and how that compares with their basic infrastructures, such as number of hospitals, number of schools etc. graph LR A1(First-time Users) A1-->A2[Step-By-Step Guide] A1-->A3[Tool] click A2 \"../../steps/data_prep/\" click A3 \"https://bmwi-tool.herokuapp.com/\" style A2 fill:#CAEEFE,stroke:#2596be,color:#063970 style A3 fill:#CAEEFE,stroke:#2596be,color:#063970 Now that you understand what you can expect, visit to the Step-By-Step Guide section of the documentation if necessary. We suggest that you open up the tool on a side-by-side window, so that you can follow and implement along with the guided instruction. Experienced Users If you are an experienced user, you can dive right in the tool! graph LR B1(Experienced Users) B1-->B2[Tool] B1-->B3[Error Handling] click B2 \"https://bmwi-tool.herokuapp.com/\" click B3 \"../../steps/error/\" style B2 fill:#CAEEFE,stroke:#2596be,color:#063970 style B3 fill:#CAEEFE,stroke:#2596be,color:#063970 If you are encountering problems, it is likely that the problem and how to solve it is already noted in our documentation. You can visit the specific page in the Step-By-Step Guide section . If you are encountering a problem that is not recorded in our documentation, please let us know. Quick Access Check out the Quick Access pages we built just for you! graph LR C1(Quick Access) C1 --> C2[Prediction Results on Tool] C1 --> C3[Quick Access documentation] click C2 \"https://bmwi-tool.herokuapp.com/#prediction-results\" click C3 \"../../start/quick/\" style C2 fill:#CAEEFE,stroke:#2596be,color:#063970 style C3 fill:#CAEEFE,stroke:#2596be,color:#063970 If you want to quickly get a grasp of the project, the tool, and the documentation, this page is for you. If you want to get a light interpretation for the latest prediction results, the home page of the tool provides rankings, and the predictions page provides line plots and a map of Germany. Technical Users The Advanced Features section contains detailed code walkthroughs. graph LR D1(Technical Users) D1 --> D3[Technical Workflow page] D1 --> D4[Installation and Setup page] click D3 \"../../advanced/tech_flow/\" click D4 \"../../advanced/installation/\" style D3 fill:#CAEEFE,stroke:#2596be,color:#063970 style D4 fill:#CAEEFE,stroke:#2596be,color:#063970 The Technical Workflow page explains the data model pipeline. Check out the Installation and Setup page to get started!","title":"Start Here"},{"location":"start/start/#start-here","text":"mermaid.initialize({startOnLoad:true}); mermaidAPI.initialize({ securityLevel: 'loose' }); \ud83e\udd2f First-time Users | \ud83d\ude0a Experienced Users | \ud83d\ude05 Quick Access | \ud83e\udd14 Technical Users Pro Tip : Clicking on the blue boxes in the flowchart brings you to the documentation page for that specific step.","title":"Start Here"},{"location":"start/start/#first-time-users","text":"This is a simplified version of the user workflow. You can find the detailed user workflow here. When you open the tool, the first page you see is the Home page. Your prediction journey starts on the Data Prep page. There, you upload the data, and do necessary preprocessing that would then feed into the model. Click here to download an Excel file containing data till May 2021. This Excel file contains the format of the input that our tool was tested on. Once you \"confirm\" the preprocessed data on the Data Prep page, you can go to the Predictions page. The data which was uploaded on the data prep page is automatically loaded on the predictions page. The predictions may take a while to run. The prediction results are cached, which means it would run faster the second time you try to predict the same data. The Visualizations page includes line plots and map visualizations to quickly understand the prediction results, e.g. which kreis has the highest unemployment rate, whether the trend for that kreis is going up or down. The Rankings page contains kreis-level and grouped rankings of unemployment rates and their percentage changes. The Error Analysis page would be automatically loaded with the prediction results. This page helps you look closer into which kreise were harder to predict, and how that compares with their basic infrastructures, such as number of hospitals, number of schools etc. graph LR A1(First-time Users) A1-->A2[Step-By-Step Guide] A1-->A3[Tool] click A2 \"../../steps/data_prep/\" click A3 \"https://bmwi-tool.herokuapp.com/\" style A2 fill:#CAEEFE,stroke:#2596be,color:#063970 style A3 fill:#CAEEFE,stroke:#2596be,color:#063970 Now that you understand what you can expect, visit to the Step-By-Step Guide section of the documentation if necessary. We suggest that you open up the tool on a side-by-side window, so that you can follow and implement along with the guided instruction.","title":"First-time Users"},{"location":"start/start/#experienced-users","text":"If you are an experienced user, you can dive right in the tool! graph LR B1(Experienced Users) B1-->B2[Tool] B1-->B3[Error Handling] click B2 \"https://bmwi-tool.herokuapp.com/\" click B3 \"../../steps/error/\" style B2 fill:#CAEEFE,stroke:#2596be,color:#063970 style B3 fill:#CAEEFE,stroke:#2596be,color:#063970 If you are encountering problems, it is likely that the problem and how to solve it is already noted in our documentation. You can visit the specific page in the Step-By-Step Guide section . If you are encountering a problem that is not recorded in our documentation, please let us know.","title":"Experienced Users"},{"location":"start/start/#quick-access","text":"Check out the Quick Access pages we built just for you! graph LR C1(Quick Access) C1 --> C2[Prediction Results on Tool] C1 --> C3[Quick Access documentation] click C2 \"https://bmwi-tool.herokuapp.com/#prediction-results\" click C3 \"../../start/quick/\" style C2 fill:#CAEEFE,stroke:#2596be,color:#063970 style C3 fill:#CAEEFE,stroke:#2596be,color:#063970 If you want to quickly get a grasp of the project, the tool, and the documentation, this page is for you. If you want to get a light interpretation for the latest prediction results, the home page of the tool provides rankings, and the predictions page provides line plots and a map of Germany.","title":"Quick Access"},{"location":"start/start/#technical-users","text":"The Advanced Features section contains detailed code walkthroughs. graph LR D1(Technical Users) D1 --> D3[Technical Workflow page] D1 --> D4[Installation and Setup page] click D3 \"../../advanced/tech_flow/\" click D4 \"../../advanced/installation/\" style D3 fill:#CAEEFE,stroke:#2596be,color:#063970 style D4 fill:#CAEEFE,stroke:#2596be,color:#063970 The Technical Workflow page explains the data model pipeline. Check out the Installation and Setup page to get started!","title":"Technical Users"},{"location":"start/user/","text":"User Worlflow mermaid.initialize({startOnLoad:true}); mermaidAPI.initialize({ securityLevel: 'loose' }); graph TD subgraph clean data A[Dataset Preparation: time-series excel workbook] end subgraph VAR model walkforward B[Predictions: unemployment rate forecasting on Kreis-level] C[Confidence Intervals: defaulted 95% confidence for predictions] end subgraph interpret predictions D[Visualizations: line plot, map of Germany and Bundesland] E[Rankings: kreise rankings and grouped rankings with line plots] end subgraph validate predictions F[Error Analysis: compare and get important structural data] end A --> B B --> C C --> D D --> E E --> F click A \"../../steps/data_prep/\" click B \"../../steps/model/#fit-model-and-export-predictions\" click D \"../../steps/visualizations/\" click E \"../../steps/rankings/\" click F \"../../steps/error/\"","title":"User Workflow"},{"location":"start/user/#user-worlflow","text":"mermaid.initialize({startOnLoad:true}); mermaidAPI.initialize({ securityLevel: 'loose' }); graph TD subgraph clean data A[Dataset Preparation: time-series excel workbook] end subgraph VAR model walkforward B[Predictions: unemployment rate forecasting on Kreis-level] C[Confidence Intervals: defaulted 95% confidence for predictions] end subgraph interpret predictions D[Visualizations: line plot, map of Germany and Bundesland] E[Rankings: kreise rankings and grouped rankings with line plots] end subgraph validate predictions F[Error Analysis: compare and get important structural data] end A --> B B --> C C --> D D --> E E --> F click A \"../../steps/data_prep/\" click B \"../../steps/model/#fit-model-and-export-predictions\" click D \"../../steps/visualizations/\" click E \"../../steps/rankings/\" click F \"../../steps/error/\"","title":"User Worlflow"},{"location":"steps/ci/","text":"Confidence intervals This section focuses on getting 95% confidence intervals for the predictions of the model. The results will include unemployment rate confidence interval predictions the next three months, for all 401 kreise. Video Documentation The following video will walk you through this section and how to use the various interactive widgets. The confidence intervals are calculated using stationary bootstrap for time-series data, which uses blocks with an exponentially distributed lengths. For more information see the Arch package . Fit confidence intervals This page automatically takes the fitted the model, and calculates 95% confidence intervals for each forecast. After the confidence intervals are calculated, it is possible to click the \"Download the confidence intervals\" link and and xslx table with the confidence intervals will be downloaded. Plot confidence intervals by kreis A time series of the predictions and confidence intervals of each kreis can be plotted. For that, chose a kreis from the drop down menu, or type its name. Then the unemployment rates will be printed, and a time series graph will be plotted. The blue line, which has the confidence intervals plotted around it, shows the predictions. The green line, with all previous values, is the ground truth, and therefore don't require confidence intervals.","title":"Confidence intervals"},{"location":"steps/ci/#confidence-intervals","text":"This section focuses on getting 95% confidence intervals for the predictions of the model. The results will include unemployment rate confidence interval predictions the next three months, for all 401 kreise.","title":"Confidence intervals"},{"location":"steps/ci/#video-documentation","text":"The following video will walk you through this section and how to use the various interactive widgets. The confidence intervals are calculated using stationary bootstrap for time-series data, which uses blocks with an exponentially distributed lengths. For more information see the Arch package .","title":"Video Documentation"},{"location":"steps/ci/#fit-confidence-intervals","text":"This page automatically takes the fitted the model, and calculates 95% confidence intervals for each forecast. After the confidence intervals are calculated, it is possible to click the \"Download the confidence intervals\" link and and xslx table with the confidence intervals will be downloaded.","title":"Fit confidence intervals"},{"location":"steps/ci/#plot-confidence-intervals-by-kreis","text":"A time series of the predictions and confidence intervals of each kreis can be plotted. For that, chose a kreis from the drop down menu, or type its name. Then the unemployment rates will be printed, and a time series graph will be plotted. The blue line, which has the confidence intervals plotted around it, shows the predictions. The green line, with all previous values, is the ground truth, and therefore don't require confidence intervals.","title":"Plot confidence intervals by kreis"},{"location":"steps/data_prep/","text":"Data Preparation Video Documentation The following video will walk you through this section and how to use the various interactive widgets. This section processes the excel file that is inputted. The excel file must contain time-series data adhering to the following rules: data should be in wide -format (the columns are different timestamps, rows are kreise) one sheet cannot have more than one variable (e.g., unemployment rate) have one column containing the kreis-level area code ags5 (\"amtlicher gemeindeschl\u00fcssel\") Time-series data excel workbook Upload Excel Workbook When you confirm that you are using an excel workbook containing time-series data, you are prompted to upload the data. In this sample screenshot, you can see that the file \"7444_318010_BMWI_Enkelmann_Eckdaten_Zeitreihe_Kreise.xlsx\" is being uploaded. Select data to clean This is the assumed workbook for labor market data: The index column \"Region\" shows that each row is a record of one kreis. The rest of the columns should represent each year and month. Each worksheet represents a different variable. For example, the current worksheet selected is \"Alo_Quote\", which stands for unemployment rate (\"Arbeitslosenquote\"). It is important that there is a sheet which is called \"Alo_Quote\" which contain the unemployment rate data. Select variable The default variable is set to \"unemployment rate\". Select data format Long format This is an example of a single-variable \"long\" format data. The dataframe contains three columns: the kreis code ( ags5 ), the time ( date ), and the variable (e.g. Alo Quote ). The number of rows of this file is 401 kreis * #dates for each kreis. Wide format This is an example of a single-variable \"wide\" format data. All the columns in the dataframe are dates. The index of the dataframe is the ags5 code. The number of rows of this file should be 401. Final dataset cleaning In this case, cropping to a certain dataframe: removing data from certain time periods that we may not want the mode to learn from. Loading dataset Here, you load the data you would like to clean. By default, it loads the data that you have confirmed processing and merging in the last section. Cropping timeframe Pro Tip : The purpose of cropping the appropriate timeframe helps differentiate between a normal-time and crisis-time model. For example, we know that there was the economic crisis around 2008 and the COVID pandemic around 2020. Thus, when doing a normal-time unemployment rate prediction, you could crop out those times so that the model is only learning the pattern from normal-time data. This is where you can select the timeframe you would like to feed into the model. In this example, a timeframe between 2007-05 and 2007-07 is selected and shown in the preview. Again, once you confirm the dataset, it would be automatically loaded in the model on the next page.","title":"Data Preparation"},{"location":"steps/data_prep/#data-preparation","text":"","title":"Data Preparation"},{"location":"steps/data_prep/#video-documentation","text":"The following video will walk you through this section and how to use the various interactive widgets. This section processes the excel file that is inputted. The excel file must contain time-series data adhering to the following rules: data should be in wide -format (the columns are different timestamps, rows are kreise) one sheet cannot have more than one variable (e.g., unemployment rate) have one column containing the kreis-level area code ags5 (\"amtlicher gemeindeschl\u00fcssel\")","title":"Video Documentation"},{"location":"steps/data_prep/#time-series-data-excel-workbook","text":"","title":"Time-series data excel workbook"},{"location":"steps/data_prep/#upload-excel-workbook","text":"When you confirm that you are using an excel workbook containing time-series data, you are prompted to upload the data. In this sample screenshot, you can see that the file \"7444_318010_BMWI_Enkelmann_Eckdaten_Zeitreihe_Kreise.xlsx\" is being uploaded.","title":"Upload Excel Workbook"},{"location":"steps/data_prep/#select-data-to-clean","text":"This is the assumed workbook for labor market data: The index column \"Region\" shows that each row is a record of one kreis. The rest of the columns should represent each year and month. Each worksheet represents a different variable. For example, the current worksheet selected is \"Alo_Quote\", which stands for unemployment rate (\"Arbeitslosenquote\"). It is important that there is a sheet which is called \"Alo_Quote\" which contain the unemployment rate data.","title":"Select data to clean"},{"location":"steps/data_prep/#select-variable","text":"The default variable is set to \"unemployment rate\".","title":"Select variable"},{"location":"steps/data_prep/#select-data-format","text":"","title":"Select data format"},{"location":"steps/data_prep/#long-format","text":"This is an example of a single-variable \"long\" format data. The dataframe contains three columns: the kreis code ( ags5 ), the time ( date ), and the variable (e.g. Alo Quote ). The number of rows of this file is 401 kreis * #dates for each kreis.","title":"Long format"},{"location":"steps/data_prep/#wide-format","text":"This is an example of a single-variable \"wide\" format data. All the columns in the dataframe are dates. The index of the dataframe is the ags5 code. The number of rows of this file should be 401.","title":"Wide format"},{"location":"steps/data_prep/#final-dataset-cleaning","text":"In this case, cropping to a certain dataframe: removing data from certain time periods that we may not want the mode to learn from.","title":"Final dataset cleaning"},{"location":"steps/data_prep/#loading-dataset","text":"Here, you load the data you would like to clean. By default, it loads the data that you have confirmed processing and merging in the last section.","title":"Loading dataset"},{"location":"steps/data_prep/#cropping-timeframe","text":"Pro Tip : The purpose of cropping the appropriate timeframe helps differentiate between a normal-time and crisis-time model. For example, we know that there was the economic crisis around 2008 and the COVID pandemic around 2020. Thus, when doing a normal-time unemployment rate prediction, you could crop out those times so that the model is only learning the pattern from normal-time data. This is where you can select the timeframe you would like to feed into the model. In this example, a timeframe between 2007-05 and 2007-07 is selected and shown in the preview. Again, once you confirm the dataset, it would be automatically loaded in the model on the next page.","title":"Cropping timeframe"},{"location":"steps/error/","text":"Error Analysis There error analysis is an attempt to see where the unemployment rate predictions \u201cfail\u201d. The errors are Mean absolute percentage errors (MAPE) , and each one represent how different the prediction is from the ground truth. The errors can be used to see which kreise were difficult to predict for, potentially suggesting the something spacial happened there. The errors can also be easily compared with the structural data, to identify the type of kreise that are harder to predict for. Video Documentation The following video will walk you through this section and how to use the various interactive widgets. Note: To calculate the errors the actual values must be available. Therefore, the errors are calculated for the previous quarter based on the recently uploaded data and, hence, this is a retrospective analysis. Launching the page To open the error analysis page, select the 'Error Analysis` Section from the dropdown on the left as can be viewed in the image below. There are a variety of different plots that can be explored and have been explained in detail below. Error Plots by Bundesland or kreis This section allows for a kreis-level or bundesland-level analysis. The left dropdown allows selection by Kreis or by Bundesland and the right dropdown allows selection of one or more regions. Selecting an individual entry would plot the errors for a specific kreis or bundesland. You can select multiple bundesland or kreis. The individual entries can be selected from the right dropdown option. Map Overview Another option is to plot the errors on a map of Germany. You can add the kreis name and the error of that kreis will be added to the map based on your selection. Kreis Level Overview The goal of the application is to break down the predictions as well as the errors at the Kreis level. The following section performs error data analysis. It helps in understanding which Kreis are the hardest to estimate for unemployment rate. This dataframe currently shows 5 kreis based on their unemployment rate forecasting errors for previous quarter. There are two configuration options here: - Highest or Lowest : This lets you select the Kreis with the highest or lowest unemployment rate prediction errors in the previous quarter. - Value Slider : This lets you select the number of Kreis to be displayed currently. From UI perspective, the maximum limit is 20 To view all the Kreis, download the complete error table by clicking on the option Download the full error table . Structural Data Analysis The next step is to analyze the errors with regards to the structural data and see hot the errors vary with a particular structural variable. Select a structural variable to compare against the errors. ( Eg: Errors are compared against eligible_area in this image ). If you chose a categorical variable, the errors are on the x-axis, so the fatter the curve is the more prone that category is to errors. In the following example, the areas which are eligible have smaller errors than areas that are not. This means that it is easier to predict kreise that are eligible for funding then kreise that are eligible. This might be because something unique happened in the eligible kreis that the model can\u2019t explain. If you chose a numerical variable, each kreis will be plotted at a seperate dot, and if there is any relationship between the errors and the variable, you might be able to see it in the plot. Most important Structural Variables Individual exploration might be interesting but can also be very time consuming. There is an option to get an overview of which features correlate to the errors and therefore explain the variance in the errors well. The features are selected using a linear regression. We fit a linear regression where the predicated value is the mean error of the kreis, and the regressors are all the structural features. We chose the most important features based on P-value, and also print the P-values. To run the regression, tick the \"run linear regression model\" box. Then, you can choose how many features you wish to print. Also, chose if you are looking for the highest P-values (important features) or the lowest (not important features).","title":"Error Analysis"},{"location":"steps/error/#error-analysis","text":"There error analysis is an attempt to see where the unemployment rate predictions \u201cfail\u201d. The errors are Mean absolute percentage errors (MAPE) , and each one represent how different the prediction is from the ground truth. The errors can be used to see which kreise were difficult to predict for, potentially suggesting the something spacial happened there. The errors can also be easily compared with the structural data, to identify the type of kreise that are harder to predict for.","title":"Error Analysis"},{"location":"steps/error/#video-documentation","text":"The following video will walk you through this section and how to use the various interactive widgets. Note: To calculate the errors the actual values must be available. Therefore, the errors are calculated for the previous quarter based on the recently uploaded data and, hence, this is a retrospective analysis.","title":"Video Documentation"},{"location":"steps/error/#launching-the-page","text":"To open the error analysis page, select the 'Error Analysis` Section from the dropdown on the left as can be viewed in the image below. There are a variety of different plots that can be explored and have been explained in detail below.","title":"Launching the page"},{"location":"steps/error/#error-plots-by-bundesland-or-kreis","text":"This section allows for a kreis-level or bundesland-level analysis. The left dropdown allows selection by Kreis or by Bundesland and the right dropdown allows selection of one or more regions. Selecting an individual entry would plot the errors for a specific kreis or bundesland. You can select multiple bundesland or kreis. The individual entries can be selected from the right dropdown option.","title":"Error Plots by Bundesland or kreis"},{"location":"steps/error/#map-overview","text":"Another option is to plot the errors on a map of Germany. You can add the kreis name and the error of that kreis will be added to the map based on your selection.","title":"Map Overview"},{"location":"steps/error/#kreis-level-overview","text":"The goal of the application is to break down the predictions as well as the errors at the Kreis level. The following section performs error data analysis. It helps in understanding which Kreis are the hardest to estimate for unemployment rate. This dataframe currently shows 5 kreis based on their unemployment rate forecasting errors for previous quarter. There are two configuration options here: - Highest or Lowest : This lets you select the Kreis with the highest or lowest unemployment rate prediction errors in the previous quarter. - Value Slider : This lets you select the number of Kreis to be displayed currently. From UI perspective, the maximum limit is 20 To view all the Kreis, download the complete error table by clicking on the option Download the full error table .","title":"Kreis Level Overview"},{"location":"steps/error/#structural-data-analysis","text":"The next step is to analyze the errors with regards to the structural data and see hot the errors vary with a particular structural variable. Select a structural variable to compare against the errors. ( Eg: Errors are compared against eligible_area in this image ). If you chose a categorical variable, the errors are on the x-axis, so the fatter the curve is the more prone that category is to errors. In the following example, the areas which are eligible have smaller errors than areas that are not. This means that it is easier to predict kreise that are eligible for funding then kreise that are eligible. This might be because something unique happened in the eligible kreis that the model can\u2019t explain. If you chose a numerical variable, each kreis will be plotted at a seperate dot, and if there is any relationship between the errors and the variable, you might be able to see it in the plot.","title":"Structural Data Analysis"},{"location":"steps/error/#most-important-structural-variables","text":"Individual exploration might be interesting but can also be very time consuming. There is an option to get an overview of which features correlate to the errors and therefore explain the variance in the errors well. The features are selected using a linear regression. We fit a linear regression where the predicated value is the mean error of the kreis, and the regressors are all the structural features. We chose the most important features based on P-value, and also print the P-values. To run the regression, tick the \"run linear regression model\" box. Then, you can choose how many features you wish to print. Also, chose if you are looking for the highest P-values (important features) or the lowest (not important features).","title":"Most important Structural Variables"},{"location":"steps/home/","text":"Home Page: Unemployment Rate Ranking The home page allows you to get quick takeaways based on the latest prediction results. The main feature of this page is to quickly see which kreis (or which group of kreise) are expected to have the highest unemployment rate for the next quarter. Kreise Ranking The first section is kreise ranking, containing three elements: Slide bar The slide bar allows you to see the top N kreise with the highest unemployment rates. It is set in a range from 10 to 100, in increments of 10. The default is set at 10. The screenshot sample is set at 30, meaning that it would show a dataframe with the top 30 highest unemployment rates. Sort-by Columns This is a multi-selection input field where you can choose multiple columns you want to sort the kreise ranking by. The ranking would then be sorted based on your input selections. The default is set to sort by three columns, in the order of: this quarter ( yyyy-mm-dd ), last quarter ( last_time% ), and the same quarter last year ( last_year% ). It is important to note that the order of your input selection matters: The input order means that it would first sort by the first input column, and then sort by the second input column if two kreis has the same result for the first input column. The input order also means that the top N kreis filtering is based on the first input column. Using the default selections as an example, the filtered result is the top N kreis based on unemployment rates of this quarter. However, the top N kreis last quarter may be a different 10 kreise. In order to get those top N kreise, you would have to put \"last quarter\" as the first sorting column in the input field. The available sort by options are: metedata index: state ( bundesland ) and county ( kreis ) all the input dates ( yyyy-mm-dd ) derived calculations: last quarter ( last_time% ): (this_Q - last_Q) / (this_Q) * 100 last year ( last_year% ): (this_Q - this_Q_last_year) / (this_Q) * 100 For example, the screenshot sample is set at the three default columns: this quarter ( 2020-03-31 ), last quarter ( last_time% ), and the same quarter last year ( last_year% ). Results After setting the number of top kreise you want to see and the columns you want to sort by, you are presented with the dataframe output of your choosing. This dataframe currently shows the top 30 kreis based on their unemployment rate this quarter, and also showing percentage change comparision to last quarter and last year, because they were in the input fields. Pro Tip : Click on a column to sort by the column. Click again to switch between ascending and descending sorting. The arrow circled in red next to the column means that the dataframe is currently sorted by that column. The arrow facing downwards means that the column is sorted in descending order. Note that even when the dataframe is sorted by the column you click, the top results is still filtered from the full dataframe based on the first input column. This dataframe currently shows the top 30 kreis based on their unemployment rate this quarter, and is also sorted by the percentage change compared to last year. For example, even though the dataframe is currently sorted by last_year% when we clicked on it, it is not sorting the top 30 kreis of last_year% based on the full dataset, but sorting based on the top 30 kreis of this quarter. Bundesland / Group Ranking The second section is bundesland / group ranking, containing five elements, following a similar format to the previous section: Slide-bar The slide bar allows you to see the top N kreise with the highest unemployment rates. It is set in a range from 50 to 200, in increments of 10. The default is set at 50. Compared to the previous section, the slide bar range is slightly larger because the reuslts in this section is grouped. Sort-by Columns Similar to the last section, the ranking would then be sorted based on your input column. Different from the last section, this section only allows you to sort by one column for simplicity. Group-by columns This multi-selection box offers a range of categorical variables to group by. The options include: bundesland : the states in Germany growth_shrink_cities (\"wachsende/schrumpfende Kreise\") east_west (\"West-/Ostdeutschland\") labor_market_type (\"IAB-Arbeitsmarkttyp der Arbeitsagentur\") settlement_type_of_labor_market_region (\"Siedlungsstrukturtyp der Arbeitsmarktregion\") district_settlement_structure (\"Siedlungsstruktureller Kreistyp\") type_of_settlement_structure (\"Siedlungsstruktureller Regionstyp\") urban_rural (\"St\u00e4dtischer Raum / L\u00e4ndlicher Raum\") metropolitan_region (\"Europ\u00e4ische Metropolregion\") support area status (\"Gemeinschaftsaufgabe Verbesserung der regionalen Wirtschaftsstruktur\") eligible area : binary variable based on support area status state area code (Amtlicher Gemeindeschl\u00fcssel, \" ags2 \") / state-level (\" bundesland \") The default is set to group by both east_west and eligible area . Results The filtering result is a multi-index dataframe with three columns. The multi-index is presented based on how many columns you group by. The three columns include: {sort_by_column} : the column to sort by in the filtering dataframe. The default is set to sort by its percentage change compared to last_year% . #kreis : the number of kreise in that grouping. %count : the proportion of kreise belonging to that sorted grouping. For example, this sample dataframe shows the top 50 kreise, sorted by last_year% , grouped by east_west and eligible area . Reading the first row: the first column, `last_year%`, means that in the top 50 kreise with highest percentage change in unemployment rate compared to last year, `21` of them belong to kreise in west Germany that are not eligible for funding. the second column, `#kreis` means that there is a total of `93` (out of all 401) kreise that are kreise in west Germany that are not eligible for funding. the third column, `%counts`, means that 21 kreise accounts for `13.5%` of all the kreise in the not-eligible-for-funding-West-Germany group. Note the number of multi-indices shown in the example. Since eligible_area have two categories, and east_west has two categories, there should be a total of 4 category groups in the index rows. However, the reason why not all combinations are shown is because some categories do not have kreise in it. Sometimes, it could be useful to see what category groups are not in the top lists. In this case, we see that there are no kreise in East Germany eligible funding in the top 50 highest unemployment rates. Visualizations Visualize the dataframe output results. As explained in the tip, when grouping by multiple columns, resulting a large number of combinations, it may be hard to see the results clearly using the pie chart or bar chart. Pie Chart The pie chart visualizes the {sort_by_column} into proportions. As shown above, the sample pie chart visualizes the percentage each category group takes in total from the last_year% column. For example, the not-eligible-for-funding-West-Germany group accounts for 21 out of the total of 50 top kreise, therefore, it takes up 42% as shown in the pie chart. Bar Chart As explained earlier, the pie chart could be a biased understanding of the category groups, and that can be balanced by understanding the percentage of those kreis accounting for the whole category group. The bar chart visualizes the %counts column. It also draws a horizontal line on the 50% mark if at least one %counts column reaches that mark. As shown above, the sample bar chart visualizes the percentage the top 50 kreise took up for its whole category group. Note that you could use the two arrows on the top right to expand the plot if the display column names is too small on your screen.","title":"Home Page: Unemployment Rate Ranking"},{"location":"steps/home/#home-page-unemployment-rate-ranking","text":"The home page allows you to get quick takeaways based on the latest prediction results. The main feature of this page is to quickly see which kreis (or which group of kreise) are expected to have the highest unemployment rate for the next quarter.","title":"Home Page: Unemployment Rate Ranking"},{"location":"steps/home/#kreise-ranking","text":"The first section is kreise ranking, containing three elements:","title":"Kreise Ranking"},{"location":"steps/home/#slide-bar","text":"The slide bar allows you to see the top N kreise with the highest unemployment rates. It is set in a range from 10 to 100, in increments of 10. The default is set at 10. The screenshot sample is set at 30, meaning that it would show a dataframe with the top 30 highest unemployment rates.","title":"Slide bar"},{"location":"steps/home/#sort-by-columns","text":"This is a multi-selection input field where you can choose multiple columns you want to sort the kreise ranking by. The ranking would then be sorted based on your input selections. The default is set to sort by three columns, in the order of: this quarter ( yyyy-mm-dd ), last quarter ( last_time% ), and the same quarter last year ( last_year% ). It is important to note that the order of your input selection matters: The input order means that it would first sort by the first input column, and then sort by the second input column if two kreis has the same result for the first input column. The input order also means that the top N kreis filtering is based on the first input column. Using the default selections as an example, the filtered result is the top N kreis based on unemployment rates of this quarter. However, the top N kreis last quarter may be a different 10 kreise. In order to get those top N kreise, you would have to put \"last quarter\" as the first sorting column in the input field. The available sort by options are: metedata index: state ( bundesland ) and county ( kreis ) all the input dates ( yyyy-mm-dd ) derived calculations: last quarter ( last_time% ): (this_Q - last_Q) / (this_Q) * 100 last year ( last_year% ): (this_Q - this_Q_last_year) / (this_Q) * 100 For example, the screenshot sample is set at the three default columns: this quarter ( 2020-03-31 ), last quarter ( last_time% ), and the same quarter last year ( last_year% ).","title":"Sort-by Columns"},{"location":"steps/home/#results","text":"After setting the number of top kreise you want to see and the columns you want to sort by, you are presented with the dataframe output of your choosing. This dataframe currently shows the top 30 kreis based on their unemployment rate this quarter, and also showing percentage change comparision to last quarter and last year, because they were in the input fields. Pro Tip : Click on a column to sort by the column. Click again to switch between ascending and descending sorting. The arrow circled in red next to the column means that the dataframe is currently sorted by that column. The arrow facing downwards means that the column is sorted in descending order. Note that even when the dataframe is sorted by the column you click, the top results is still filtered from the full dataframe based on the first input column. This dataframe currently shows the top 30 kreis based on their unemployment rate this quarter, and is also sorted by the percentage change compared to last year. For example, even though the dataframe is currently sorted by last_year% when we clicked on it, it is not sorting the top 30 kreis of last_year% based on the full dataset, but sorting based on the top 30 kreis of this quarter.","title":"Results"},{"location":"steps/home/#bundesland-group-ranking","text":"The second section is bundesland / group ranking, containing five elements, following a similar format to the previous section:","title":"Bundesland / Group Ranking"},{"location":"steps/home/#slide-bar_1","text":"The slide bar allows you to see the top N kreise with the highest unemployment rates. It is set in a range from 50 to 200, in increments of 10. The default is set at 50. Compared to the previous section, the slide bar range is slightly larger because the reuslts in this section is grouped.","title":"Slide-bar"},{"location":"steps/home/#sort-by-columns_1","text":"Similar to the last section, the ranking would then be sorted based on your input column. Different from the last section, this section only allows you to sort by one column for simplicity.","title":"Sort-by Columns"},{"location":"steps/home/#group-by-columns","text":"This multi-selection box offers a range of categorical variables to group by. The options include: bundesland : the states in Germany growth_shrink_cities (\"wachsende/schrumpfende Kreise\") east_west (\"West-/Ostdeutschland\") labor_market_type (\"IAB-Arbeitsmarkttyp der Arbeitsagentur\") settlement_type_of_labor_market_region (\"Siedlungsstrukturtyp der Arbeitsmarktregion\") district_settlement_structure (\"Siedlungsstruktureller Kreistyp\") type_of_settlement_structure (\"Siedlungsstruktureller Regionstyp\") urban_rural (\"St\u00e4dtischer Raum / L\u00e4ndlicher Raum\") metropolitan_region (\"Europ\u00e4ische Metropolregion\") support area status (\"Gemeinschaftsaufgabe Verbesserung der regionalen Wirtschaftsstruktur\") eligible area : binary variable based on support area status state area code (Amtlicher Gemeindeschl\u00fcssel, \" ags2 \") / state-level (\" bundesland \") The default is set to group by both east_west and eligible area .","title":"Group-by columns"},{"location":"steps/home/#results_1","text":"The filtering result is a multi-index dataframe with three columns. The multi-index is presented based on how many columns you group by. The three columns include: {sort_by_column} : the column to sort by in the filtering dataframe. The default is set to sort by its percentage change compared to last_year% . #kreis : the number of kreise in that grouping. %count : the proportion of kreise belonging to that sorted grouping. For example, this sample dataframe shows the top 50 kreise, sorted by last_year% , grouped by east_west and eligible area . Reading the first row: the first column, `last_year%`, means that in the top 50 kreise with highest percentage change in unemployment rate compared to last year, `21` of them belong to kreise in west Germany that are not eligible for funding. the second column, `#kreis` means that there is a total of `93` (out of all 401) kreise that are kreise in west Germany that are not eligible for funding. the third column, `%counts`, means that 21 kreise accounts for `13.5%` of all the kreise in the not-eligible-for-funding-West-Germany group. Note the number of multi-indices shown in the example. Since eligible_area have two categories, and east_west has two categories, there should be a total of 4 category groups in the index rows. However, the reason why not all combinations are shown is because some categories do not have kreise in it. Sometimes, it could be useful to see what category groups are not in the top lists. In this case, we see that there are no kreise in East Germany eligible funding in the top 50 highest unemployment rates.","title":"Results"},{"location":"steps/home/#visualizations","text":"Visualize the dataframe output results. As explained in the tip, when grouping by multiple columns, resulting a large number of combinations, it may be hard to see the results clearly using the pie chart or bar chart.","title":"Visualizations"},{"location":"steps/home/#pie-chart","text":"The pie chart visualizes the {sort_by_column} into proportions. As shown above, the sample pie chart visualizes the percentage each category group takes in total from the last_year% column. For example, the not-eligible-for-funding-West-Germany group accounts for 21 out of the total of 50 top kreise, therefore, it takes up 42% as shown in the pie chart.","title":"Pie Chart"},{"location":"steps/home/#bar-chart","text":"As explained earlier, the pie chart could be a biased understanding of the category groups, and that can be balanced by understanding the percentage of those kreis accounting for the whole category group. The bar chart visualizes the %counts column. It also draws a horizontal line on the 50% mark if at least one %counts column reaches that mark. As shown above, the sample bar chart visualizes the percentage the top 50 kreise took up for its whole category group. Note that you could use the two arrows on the top right to expand the plot if the display column names is too small on your screen.","title":"Bar Chart"},{"location":"steps/model/","text":"Predictions This section focuses on getting the results from the model. The results will include unemployment rate predictions the next three months, for all 401 kreise. After the model it fitted, it is possible to download and visualize the predictions. Video Documentation The following video will walk you through this section and how to use the various interactive widgets. Fit Model and Export Predictions This page automatically takes the cleaned dataset and fits the model on it. The model being fitted is a Vector Autoregression (VAR) model, which is a multivariate forecasting algorithm used when two or more time series influence each other. The model uses the PCA & K-means clusters. More on the model and clusters is explained on our journey the fitting might take a few minutes. After the model is fitted, a preview of the predictions table is showed. The table has three columns, each one holding the unemployment rate predictions for one month, and each row is a different kreis. After the model is fitted, it is possible to click the \"Download the predictions\" link and and xslx table with the predictions will be downloaded. Aggregation of Predictions The predictions from the County level are aggregated to the Bundesland and Country level using a weighted mean, weighted on the population of the kreise. NOTE: The populations used to aggregate are data from the timeframe: December 31, 2018 - December 31, 2019, collected from corona-datenplattform .","title":"Predictions"},{"location":"steps/model/#predictions","text":"This section focuses on getting the results from the model. The results will include unemployment rate predictions the next three months, for all 401 kreise. After the model it fitted, it is possible to download and visualize the predictions.","title":"Predictions"},{"location":"steps/model/#video-documentation","text":"The following video will walk you through this section and how to use the various interactive widgets.","title":"Video Documentation"},{"location":"steps/model/#fit-model-and-export-predictions","text":"This page automatically takes the cleaned dataset and fits the model on it. The model being fitted is a Vector Autoregression (VAR) model, which is a multivariate forecasting algorithm used when two or more time series influence each other. The model uses the PCA & K-means clusters. More on the model and clusters is explained on our journey the fitting might take a few minutes. After the model is fitted, a preview of the predictions table is showed. The table has three columns, each one holding the unemployment rate predictions for one month, and each row is a different kreis. After the model is fitted, it is possible to click the \"Download the predictions\" link and and xslx table with the predictions will be downloaded.","title":"Fit Model and Export Predictions"},{"location":"steps/model/#aggregation-of-predictions","text":"The predictions from the County level are aggregated to the Bundesland and Country level using a weighted mean, weighted on the population of the kreise. NOTE: The populations used to aggregate are data from the timeframe: December 31, 2018 - December 31, 2019, collected from corona-datenplattform .","title":"Aggregation of Predictions"},{"location":"steps/rankings/","text":"Unemployment Rate Ranking The ranking page allows you to get quick takeaways based on the latest prediction results. The main feature of this page is to quickly see which kreis (or which group of kreise) are expected to have the highest (or lowest) unemployment rate for the next quarter. Kreise Ranking The first section is kreise ranking, containing four elements: Slidebar The slide bar allows you to see the top N kreise with the highest unemployment rates. It is set in a range from 50 to 401, in increments of 50. The default is set at 100. Sort-by Columns Then, you need to choose which column to sort by The options are: A specific ground truth month A specific predicted month Difference in unemployment rate compared to last month ( month diff ) Difference in unemployment rate compared to this month last year ( year diff ) Percentage of change in unemployment rate compared to same time last month ( % month diff ) Percentage of change in unemployment rate compared to same time last year ( % year diff ) Additional Columns This is a multi-selection input field where you can choose multiple columns you want to also see in the sorted dataframe. Ascending order? It is automatically printied in an descending order. If you tick the \"ascending order\" box, it will order by ascending order. Results After setting the number of top kreise you want to filter in, the column you want to sort by, and the additional information you want to see, you are presented with the dataframe output of your choosing. You also have the choice to download that specific subset of the dataframe. Grouped Ranking The second section is categorical group ranking, following up the dataframe we used in the previous section: Group-by columns This multi-selection box offers a range of categorical variables to group by. The options include: bundesland : the states in Germany growth_shrink_cities (\"wachsende/schrumpfende Kreise\") east_west (\"West-/Ostdeutschland\") labor_market_type (\"IAB-Arbeitsmarkttyp der Arbeitsagentur\") settlement_type_of_labor_market_region (\"Siedlungsstrukturtyp der Arbeitsmarktregion\") district_settlement_structure (\"Siedlungsstruktureller Kreistyp\") type_of_settlement_structure (\"Siedlungsstruktureller Regionstyp\") urban_rural (\"St\u00e4dtischer Raum / L\u00e4ndlicher Raum\") support area status (\"Gemeinschaftsaufgabe Verbesserung der regionalen Wirtschaftsstruktur\") eligible area : binary variable based on support area status state area code (Amtlicher Gemeindeschl\u00fcssel, \" ags2 \") / state-level (\" bundesland \") The default is set to group by both east_west and eligible area . Results The filtering result is a multi-index dataframe with three columns. The multi-index is presented based on how many columns you group by. The three columns include: {sort_by_column} : the column to sort by in the filtering dataframe. The default is set to sort by its percentage change compared to last_year% . #kreis : the number of kreise in that grouping. %count : the proportion of kreise belonging to that sorted grouping. For example, this sample dataframe shows the top 100 kreise, sorted by last_year% , grouped by east_west and eligible area . Reading the first row: the first column, `last_year%`, means that in the top 100 kreise with highest percentage change in unemployment rate compared to last year, `43` of them belong to kreise in west Germany that are eligible for funding. the second column, `#kreis` means that there is a total of `93` (out of all 401) kreise that are kreise in west Germany that are eligible for funding. the third column, `%counts`, means that 43 kreise accounts for `46.24%` of all the kreise in the eligible-for-funding-West-Germany group. Note that the last row is 0 . Sometimes, it could be useful to see what category groups are not in the top lists. In this case, we see that there are no kreise in East Germany not eligible funding in the top 100 highest unemployment rates. Visualizations Visualize the dataframe output results. As explained in the tip, when grouping by multiple columns, resulting a large number of combinations, it may be hard to see the results clearly using the pie chart or bar chart. Line Plot As shown above, the sample line plot visualizes the unemployment trend in each category group. For example, we can see that the east region historically always had higher unemployment rates than the west region. We can also see that the group eligible for funding also always had higher unemployment rate.s Pie Chart The pie chart visualizes the {sort_by_column} into proportions. As shown above, the sample pie chart visualizes the percentage each category group takes in total from the last_year% column. For example, the not-eligible-for-funding-West-Germany group accounts for 43 out of the total of 100 top kreise, therefore, it takes up 43% as shown in the pie chart. Bar Chart As explained earlier, the pie chart could be a biased understanding of the category groups, and that can be balanced by understanding the percentage of those kreis accounting for the whole category group. The bar chart visualizes the %counts column. It also draws a horizontal line on the 50% mark if at least one %counts column reaches that mark. As shown above, the sample bar chart visualizes the percentage the top 100 kreise took up for its whole category group. Note that you could use the two arrows on the top right to expand the plot if the display column names is too small on your screen.","title":"Rankings"},{"location":"steps/rankings/#unemployment-rate-ranking","text":"The ranking page allows you to get quick takeaways based on the latest prediction results. The main feature of this page is to quickly see which kreis (or which group of kreise) are expected to have the highest (or lowest) unemployment rate for the next quarter.","title":"Unemployment Rate Ranking"},{"location":"steps/rankings/#kreise-ranking","text":"The first section is kreise ranking, containing four elements:","title":"Kreise Ranking"},{"location":"steps/rankings/#slidebar","text":"The slide bar allows you to see the top N kreise with the highest unemployment rates. It is set in a range from 50 to 401, in increments of 50. The default is set at 100.","title":"Slidebar"},{"location":"steps/rankings/#sort-by-columns","text":"Then, you need to choose which column to sort by The options are: A specific ground truth month A specific predicted month Difference in unemployment rate compared to last month ( month diff ) Difference in unemployment rate compared to this month last year ( year diff ) Percentage of change in unemployment rate compared to same time last month ( % month diff ) Percentage of change in unemployment rate compared to same time last year ( % year diff )","title":"Sort-by Columns"},{"location":"steps/rankings/#additional-columns","text":"This is a multi-selection input field where you can choose multiple columns you want to also see in the sorted dataframe.","title":"Additional Columns"},{"location":"steps/rankings/#ascending-order","text":"It is automatically printied in an descending order. If you tick the \"ascending order\" box, it will order by ascending order.","title":"Ascending order?"},{"location":"steps/rankings/#results","text":"After setting the number of top kreise you want to filter in, the column you want to sort by, and the additional information you want to see, you are presented with the dataframe output of your choosing. You also have the choice to download that specific subset of the dataframe.","title":"Results"},{"location":"steps/rankings/#grouped-ranking","text":"The second section is categorical group ranking, following up the dataframe we used in the previous section:","title":"Grouped Ranking"},{"location":"steps/rankings/#group-by-columns","text":"This multi-selection box offers a range of categorical variables to group by. The options include: bundesland : the states in Germany growth_shrink_cities (\"wachsende/schrumpfende Kreise\") east_west (\"West-/Ostdeutschland\") labor_market_type (\"IAB-Arbeitsmarkttyp der Arbeitsagentur\") settlement_type_of_labor_market_region (\"Siedlungsstrukturtyp der Arbeitsmarktregion\") district_settlement_structure (\"Siedlungsstruktureller Kreistyp\") type_of_settlement_structure (\"Siedlungsstruktureller Regionstyp\") urban_rural (\"St\u00e4dtischer Raum / L\u00e4ndlicher Raum\") support area status (\"Gemeinschaftsaufgabe Verbesserung der regionalen Wirtschaftsstruktur\") eligible area : binary variable based on support area status state area code (Amtlicher Gemeindeschl\u00fcssel, \" ags2 \") / state-level (\" bundesland \") The default is set to group by both east_west and eligible area .","title":"Group-by columns"},{"location":"steps/rankings/#results_1","text":"The filtering result is a multi-index dataframe with three columns. The multi-index is presented based on how many columns you group by. The three columns include: {sort_by_column} : the column to sort by in the filtering dataframe. The default is set to sort by its percentage change compared to last_year% . #kreis : the number of kreise in that grouping. %count : the proportion of kreise belonging to that sorted grouping. For example, this sample dataframe shows the top 100 kreise, sorted by last_year% , grouped by east_west and eligible area . Reading the first row: the first column, `last_year%`, means that in the top 100 kreise with highest percentage change in unemployment rate compared to last year, `43` of them belong to kreise in west Germany that are eligible for funding. the second column, `#kreis` means that there is a total of `93` (out of all 401) kreise that are kreise in west Germany that are eligible for funding. the third column, `%counts`, means that 43 kreise accounts for `46.24%` of all the kreise in the eligible-for-funding-West-Germany group. Note that the last row is 0 . Sometimes, it could be useful to see what category groups are not in the top lists. In this case, we see that there are no kreise in East Germany not eligible funding in the top 100 highest unemployment rates.","title":"Results"},{"location":"steps/rankings/#visualizations","text":"Visualize the dataframe output results. As explained in the tip, when grouping by multiple columns, resulting a large number of combinations, it may be hard to see the results clearly using the pie chart or bar chart.","title":"Visualizations"},{"location":"steps/rankings/#line-plot","text":"As shown above, the sample line plot visualizes the unemployment trend in each category group. For example, we can see that the east region historically always had higher unemployment rates than the west region. We can also see that the group eligible for funding also always had higher unemployment rate.s","title":"Line Plot"},{"location":"steps/rankings/#pie-chart","text":"The pie chart visualizes the {sort_by_column} into proportions. As shown above, the sample pie chart visualizes the percentage each category group takes in total from the last_year% column. For example, the not-eligible-for-funding-West-Germany group accounts for 43 out of the total of 100 top kreise, therefore, it takes up 43% as shown in the pie chart.","title":"Pie Chart"},{"location":"steps/rankings/#bar-chart","text":"As explained earlier, the pie chart could be a biased understanding of the category groups, and that can be balanced by understanding the percentage of those kreis accounting for the whole category group. The bar chart visualizes the %counts column. It also draws a horizontal line on the 50% mark if at least one %counts column reaches that mark. As shown above, the sample bar chart visualizes the percentage the top 100 kreise took up for its whole category group. Note that you could use the two arrows on the top right to expand the plot if the display column names is too small on your screen.","title":"Bar Chart"},{"location":"steps/visualizations/","text":"Visualizations This section allowas you to on see visualizations of the model results. Video Documentation The following video will walk you through this section and how to use the various interactive widgets. Predictions Line Plot A time series of the predictions of each kreis can be plotted. For that, you need to chose a kreis from the drop down menu, or type its name. Then the unemployment rate predictions will be printed, and a time series graph will be plotted. It is also possible to choose multiple kreise. Then, the unemployment rate predictions for each kreis will be printed separately, and a time series graph for all kreise will be plotted. The graph shows the values of each kreis in a different line. The ground truth unemployment rates in different colors on the left, and the predicted values in red on the right. It is also possible to pick the start date for the graph, which is helpful if you are interested in a very short or long time period. Predictions Map Choose variable to plot map Another option is to plot the unemployment rates on a map of Germany. First, you need to choose which unemployment rate to plot. The options are: A specific ground truth month A specific predicted month Difference in unemployment rate compared to last month Difference in unemployment rate compared to this month last year Percentage of change in unemployment rate compared to same time last month Percentage of change in unemployment rate compared to same time last year An average of the three predicted months This is a kreis-level map of Germany based on unemployment rate on predicted for August 2021. Adding labels to the map You can add the kreis name and unemployment rate of that kreis will be added to the map based on your selection. add labels based on kreis After choosing a column, it is also possible to add labels of a specific kreis to the plot. For that,choose a kreis from the drop down menu or type its name. The label of the kreis will be added to the map, along with the value. add labels based on bundesland It is also possible to look at a map of a specific bundesland. First, you need to choose which unemployment rate to plot. Then, chose a bundesland from the drop down menu or type its name. Automatically, the kreise with the highest values will be marked and their values will be plotted. It is possible to add labels of a specific kreis from this bundesland to the plot. For that, choose a kreis from the drop down menu or type its name. The label of the kreis will be added to the map, along with the value.","title":"Visualizations"},{"location":"steps/visualizations/#visualizations","text":"This section allowas you to on see visualizations of the model results.","title":"Visualizations"},{"location":"steps/visualizations/#video-documentation","text":"The following video will walk you through this section and how to use the various interactive widgets.","title":"Video Documentation"},{"location":"steps/visualizations/#predictions-line-plot","text":"A time series of the predictions of each kreis can be plotted. For that, you need to chose a kreis from the drop down menu, or type its name. Then the unemployment rate predictions will be printed, and a time series graph will be plotted. It is also possible to choose multiple kreise. Then, the unemployment rate predictions for each kreis will be printed separately, and a time series graph for all kreise will be plotted. The graph shows the values of each kreis in a different line. The ground truth unemployment rates in different colors on the left, and the predicted values in red on the right. It is also possible to pick the start date for the graph, which is helpful if you are interested in a very short or long time period.","title":"Predictions Line Plot"},{"location":"steps/visualizations/#predictions-map","text":"","title":"Predictions Map"},{"location":"steps/visualizations/#choose-variable-to-plot-map","text":"Another option is to plot the unemployment rates on a map of Germany. First, you need to choose which unemployment rate to plot. The options are: A specific ground truth month A specific predicted month Difference in unemployment rate compared to last month Difference in unemployment rate compared to this month last year Percentage of change in unemployment rate compared to same time last month Percentage of change in unemployment rate compared to same time last year An average of the three predicted months This is a kreis-level map of Germany based on unemployment rate on predicted for August 2021.","title":"Choose variable to plot map"},{"location":"steps/visualizations/#adding-labels-to-the-map","text":"You can add the kreis name and unemployment rate of that kreis will be added to the map based on your selection.","title":"Adding labels to the map"},{"location":"steps/visualizations/#add-labels-based-on-kreis","text":"After choosing a column, it is also possible to add labels of a specific kreis to the plot. For that,choose a kreis from the drop down menu or type its name. The label of the kreis will be added to the map, along with the value.","title":"add labels based on kreis"},{"location":"steps/visualizations/#add-labels-based-on-bundesland","text":"It is also possible to look at a map of a specific bundesland. First, you need to choose which unemployment rate to plot. Then, chose a bundesland from the drop down menu or type its name. Automatically, the kreise with the highest values will be marked and their values will be plotted. It is possible to add labels of a specific kreis from this bundesland to the plot. For that, choose a kreis from the drop down menu or type its name. The label of the kreis will be added to the map, along with the value.","title":"add labels based on bundesland"}]}